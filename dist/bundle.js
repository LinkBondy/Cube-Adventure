/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./files/data/GameData.js":
/*!********************************!*\
  !*** ./files/data/GameData.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BackgroundStyles\": () => (/* binding */ BackgroundStyles),\n/* harmony export */   \"ShopMode\": () => (/* binding */ ShopMode),\n/* harmony export */   \"cubeStyle\": () => (/* binding */ cubeStyle),\n/* harmony export */   \"dataManagement\": () => (/* binding */ dataManagement),\n/* harmony export */   \"drawUpdate\": () => (/* binding */ drawUpdate),\n/* harmony export */   \"gameMode\": () => (/* binding */ gameMode),\n/* harmony export */   \"gameStates\": () => (/* binding */ gameStates),\n/* harmony export */   \"levelTools\": () => (/* binding */ levelTools),\n/* harmony export */   \"settingStates\": () => (/* binding */ settingStates),\n/* harmony export */   \"startingMenusStates\": () => (/* binding */ startingMenusStates),\n/* harmony export */   \"storyModeStates\": () => (/* binding */ storyModeStates)\n/* harmony export */ });\n\nconst startingMenusStates = {\n  // NewInfo: 1,\n  NotStarted: 1,\n  Menu: 2,\n  Selected: 3\n}\n\nconst gameMode = {\n  StoryMode: 1,\n  Shop: 2,\n  ItemsInfo: 3,\n  Settings: 4\n}\n\nconst storyModeStates = {\n  Selecting: 1,\n  Playing: 2,\n  Lost: 3,\n  WonStage: 4,\n  Paused: 5\n}\n\nconst ShopMode/* shopStates */ = {\n  ShopMenu: 1,\n  Backround: 2,\n  Player: 3\n}\n\nconst BackgroundStyles = {\n  Classic: 0,\n  Plastic: 1\n}\n\nconst cubeStyle = {\n  Classic: 0,\n  Alien: 1,\n  Sad: 2,\n  Happy: 3\n}\n\nconst settingStates = {\n  Selecting: 1,\n  Keybinds: 2,\n  ThemeColourSelection: 3,\n  Sound: 4\n}\n\nconst gameStates = {\n  currentStartingMenusState: startingMenusStates.NotStarted,\n  currentStoryModeState: storyModeStates.Selecting,\n  currentSettingState: settingStates.Selecting,\n  currentGameMode: gameMode.StoryMode,\n  currentShopMode: ShopMode.ShopMenu,\n  currentBackgroundStyle: BackgroundStyles.Classic,\n  currentCubeStyle: cubeStyle.BlueCube,\n  currentThemeColour: 'lightgray',\n  currentLevelIndex: 0,\n  mobile: false,\n  loading: true,\n  CurrentLevel: function () {\n    return gameStates.levelController.levels[gameStates.currentLevelIndex]\n  },\n\n  SetGameState: function (gameState, type) {\n    if (type === 'Starting') { gameStates.currentStartingMenusState = gameState }\n    if (type === 'StoryMode') { gameStates.currentStoryModeState = gameState }\n    if (type === 'Settings') { gameStates.currentSettingState = gameState }\n  }\n}\n\nconst drawUpdate = {\n  highestLevelLock: true,\n  blueCubeSadLock: true,\n  blueCubeAlienLock: true\n}\n\nconst levelTools = {\n  currentLosses: 0,\n  loseCounterStop: false,\n  winLevel: false,\n  NextLevel: function () {\n    levelTools.Restart()\n    if (gameStates.infoController.unlockedLevel === gameStates.currentLevelIndex) { gameStates.infoController.unlockedLevel++ }\n  },\n\n  Restart: function () {\n    gameStates.CurrentLevel().players.forEach(function (player) {\n        player.reset()\n    })\n\n    gameStates.CurrentLevel().finishAreas.forEach(function (finishArea) {\n      finishArea.reset()\n    })\n\n    gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n      enemy.reset()\n    })\n\n    gameStates.CurrentLevel().waters.forEach(function (water) {\n      water.reset()\n    })\n\n    gameStates.CurrentLevel().holes.forEach(function (hole) {\n      hole.reset()\n    })\n\n    gameStates.CurrentLevel().unlocks.forEach(function (unlock) {\n      unlock.reset()\n    })\n\n    gameStates.CurrentLevel().teleporters.forEach(function (teleporter) {\n      teleporter.reset()\n    })\n\n    gameStates.CurrentLevel().items.forEach(function (item) {\n      item.reset()\n    })\n\n    gameStates.CurrentLevel().rocks.forEach(function (rock) {\n      rock.reset()\n    })\n\n    gameStates.CurrentLevel().changeDirectionSquares.forEach(function (changeDirectionSquare) {\n      changeDirectionSquare.reset()\n    })\n\n    gameStates.CurrentLevel().walls.forEach(function (wall) {\n      wall.reset()\n    })\n    gameStates.CurrentLevel().currentX = gameStates.CurrentLevel().startingX\n    gameStates.CurrentLevel().currentY = gameStates.CurrentLevel().startingY\n  }\n}\n\nconst dataManagement = {\n  Save: function (draw) {\n    window.localStorage.setItem('level', gameStates.infoController.unlockedLevel)\n    window.localStorage.setItem('newUpdate', false)\n    if (gameStates.infoController.unlockedLevel !== gameStates.levelController.levels.length && gameStates.infoController.unlockedLevel === gameStates.currentLevelIndex - 1) {\n      window.localStorage.setItem('stateGame', gameStates.currentStoryModeState)\n    } else { window.localStorage.setItem('stateGame', -1) }\n    window.localStorage.setItem('PlayerAlienLock', drawUpdate.blueCubeAlienLock)\n    window.localStorage.setItem('PlayerSadLock', drawUpdate.blueCubeSadLock)\n    window.localStorage.setItem('highestLevelLock', drawUpdate.highestLevelLock)\n    window.localStorage.setItem('StyleCube', gameStates.currentCubeStyle)\n    window.localStorage.setItem('backgroundStyle', gameStates.currentBackgroundStyle)\n    window.localStorage.setItem('currentThemeColourSelection', gameStates.arrayChartController.arrayCharts[0].currentSelection)\n    window.localStorage.setItem('keybindArray', JSON.stringify(gameStates.keybindController.keybinds))\n  },\n\n  Load: function () {\n    const newUpdate = window.localStorage.getItem('newUpdate')\n    if (newUpdate !== null) {\n      const level = Number(window.localStorage.getItem('level'))\n      const stateGame = Number(window.localStorage.getItem('stateGame'))\n      if (level !== null) {\n        gameStates.infoController.unlockedLevel = level\n        if (stateGame === storyModeStates.WonStage) {\n          gameStates.infoController.unlockedLevel++\n        }\n      }\n    }\n\n    if (window.localStorage.getItem('highestLevelLock') !== null) {\n      const highestLevelLock = JSON.parse(window.localStorage.getItem('highestLevelLock'))\n      drawUpdate.highestLevelLock = highestLevelLock\n    }\n\n    if (window.localStorage.getItem('PlayerSadLock') !== null) {\n      const SadLock = JSON.parse(window.localStorage.getItem('PlayerSadLock'))\n      drawUpdate.blueCubeSadLock = SadLock\n    }\n\n    if (window.localStorage.getItem('PlayerAlienLock') !== null) {\n      const AlienLock = JSON.parse(window.localStorage.getItem('PlayerAlienLock'))\n      drawUpdate.blueCubeAlienLock = AlienLock\n    }\n\n    const BackgroundStyle = Number(window.localStorage.getItem('backgroundStyle'))\n    if (BackgroundStyle !== null) {\n      gameStates.currentBackgroundStyle = BackgroundStyle\n    }\n\n    const currentThemeColourSelection = window.localStorage.getItem('currentThemeColourSelection')\n    if (currentThemeColourSelection !== null) {\n      gameStates.currentThemeColour = gameStates.arrayChartController.arrayCharts[0].items[currentThemeColourSelection].value\n      gameStates.arrayChartController.arrayCharts[0].currentSelection = currentThemeColourSelection\n    }\n\n    const StyleCube = Number(window.localStorage.getItem('StyleCube'))\n    if (StyleCube !== null) {\n      gameStates.currentCubeStyle = StyleCube\n    }\n\n    const loadArrayKeybind = JSON.parse(window.localStorage.getItem('keybindArray'))\n    if (loadArrayKeybind !== null) { gameStates.keybindController.load(loadArrayKeybind) }\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/data/GameData.js?");

/***/ }),

/***/ "./files/data/Update.js":
/*!******************************!*\
  !*** ./files/data/Update.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"update\": () => (/* binding */ update)\n/* harmony export */ });\n\nconst { gameMode, storyModeStates, gameStates, levelTools, settingStates, drawUpdate } = __webpack_require__(/*! ./GameData */ \"./files/data/GameData.js\")\n\nconst update = {\n    UpdateGame: function (delta) {\n      if (gameStates.currentStoryModeState === storyModeStates.Playing && gameStates.currentGameMode === gameMode.StoryMode) { this.updateLevels(delta) }\n  \n      if (gameStates.arrayChartController.findCurrentArrayChart() !== false) { this.chartUpdate() }\n  \n      if (gameStates.currentSettingState === settingStates.Keybinds && gameStates.currentGameMode === gameMode.Settings) { this.keybindUpdate() }\n  \n      this.checkWinLose()\n      this.drawUpdate()\n    },\n  \n    chartUpdate: function () {\n      let numberDrew = 0\n      for (let col = 0; col < gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].loopHeight; col++) {\n        for (let row = 0; row < gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].loopWidth; row++) {\n          gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].items[numberDrew].Update()\n          numberDrew++\n        }\n      }\n      gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].update()\n    },\n  \n    keybindUpdate: function () {\n      gameStates.keybindController.keybinds.forEach(function (keybind) {\n        keybind.Update()\n      })\n    },\n  \n    drawUpdate: function () {\n      if (gameStates.infoController.unlockedLevel === gameStates.levelController.levels.length) { drawUpdate.highestLevelLock = false }\n    },\n  \n    updateLevels: function (delta) {\n      if (gameStates.currentStoryModeState === storyModeStates.Playing && gameStates.currentGameMode === gameMode.StoryMode) {\n        gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n          enemy.update(delta)\n        })\n        gameStates.CurrentLevel().players.forEach(function (player) {\n          player.update(delta)\n          player.changeSlideVariables()\n        })\n        gameStates.CurrentLevel().unlocks.forEach(function (unlock) {\n          unlock.update(delta)\n        })\n        gameStates.CurrentLevel().holes.forEach(function (hole) {\n          hole.update(delta)\n        })\n        gameStates.CurrentLevel().items.forEach(function (item) {\n          item.update(delta)\n        })\n        gameStates.CurrentLevel().teleporters.forEach(function (teleporter) {\n          teleporter.update(delta)\n        })\n      }\n    },\n\n    updateLose: function() {\n    if (levelTools.loseCounterStop === false) {\n        levelTools.currentLosses = levelTools.currentLosses + 1\n        if (levelTools.currentLosses === 50) {\n          drawUpdate.blueCubeSadLock = false\n        }\n        levelTools.loseCounterStop = true\n      }\n    },\n  \n    checkWinLose: function () {\n      if (this.checkWin() && gameStates.currentStoryModeState !== storyModeStates.WonStage && !levelTools.winLevel) {\n        levelTools.winLevel = true\n        setTimeout(function () {\n          gameStates.SetGameState(storyModeStates.WonStage, 'StoryMode')\n          levelTools.winLevel = false\n        }, 300)\n      } else if (this.checkLose() && gameStates.currentStoryModeState !== storyModeStates.Lost && !levelTools.loseLevel) {\n        levelTools.loseLevel = true\n        setTimeout(function () {\n          update.updateLose()\n          gameStates.SetGameState(storyModeStates.Lost, 'StoryMode')\n          levelTools.loseLevel = false\n        }, 30)\n      }\n    },\n  \n    checkWin: function () {\n      let win = false\n      gameStates.CurrentLevel().players.forEach(function (player) {\n        gameStates.CurrentLevel().finishAreas.forEach(function (finishArea) {\n          if (finishArea.intersects(player)) {\n            win = true\n          }\n        })\n      })\n      return win\n    },\n  \n    checkLose: function () {\n      let lose = false\n      gameStates.CurrentLevel().players.forEach(function (player) {\n        gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n          if (player.intersects(enemy)) {\n            lose = true\n          }\n        })\n        gameStates.CurrentLevel().holes.forEach(function (hole) {\n          if (player.intersectsAll(hole) && hole.fullHole) {\n            lose = true\n          }\n        })\n      })\n      return lose\n    },\n}\n\n//# sourceURL=webpack://cube-adventure/./files/data/Update.js?");

/***/ }),

/***/ "./files/drawing/Canvas.js":
/*!*********************************!*\
  !*** ./files/drawing/Canvas.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canvas\": () => (/* binding */ canvas)\n/* harmony export */ });\n\nclass Canvas {\n  createCanvasContext () {\n    const canvas = document.getElementById('mycanvas')\n    this.context = canvas.getContext('2d')\n    this.width = canvas.width\n    this.height = canvas.height\n  }\n}\n\nconst canvas = new Canvas()\n\n\n//# sourceURL=webpack://cube-adventure/./files/drawing/Canvas.js?");

/***/ }),

/***/ "./files/drawing/Draw.js":
/*!*******************************!*\
  !*** ./files/drawing/Draw.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"draw\": () => (/* binding */ draw)\n/* harmony export */ });\n\nconst { gameMode, startingMenusStates, storyModeStates, ShopMode, gameStates, levelTools, settingStates } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ./Canvas */ \"./files/drawing/Canvas.js\")\nconst { images } = __webpack_require__(/*! ./Images */ \"./files/drawing/Images.js\")\nconst draw = {\n  DrawImage: function (image, x, y) {\n    canvas.context.drawImage(image, 0, 0, image.width, image.height, x, y, image.width, image.height)\n  },\n  ChangeShdow: function (offsetX, offsetY, offsetColour) {\n    canvas.context.shadowOffsetX = offsetX\n    canvas.context.shadowOffsetY = offsetY\n    canvas.context.shadowColor = offsetColour\n  },\n  DrawGame: function () {\n    gameStates.background.DrawBackround()\n    if (gameStates.currentStartingMenusState === startingMenusStates.Selected) {\n      if (gameStates.currentGameMode === gameMode.StoryMode) { this.StoryModeDraw() }\n\n      if (gameStates.currentGameMode === gameMode.Shop) { this.ShopDraw() }\n\n      if (gameStates.currentGameMode === gameMode.ItemsInfo) { gameStates.infoController.Draw() }\n\n      if (gameStates.currentGameMode === gameMode.Settings) { this.SettingsDraw() }\n\n      if (gameStates.arrayChartController.findCurrentArrayChart() !== false) { this.DrawCharts() }\n    } else {\n      if (gameStates.currentStartingMenusState === startingMenusStates.NotStarted) { this.StartingSreenDraw() }\n      if (gameStates.currentStartingMenusState === startingMenusStates.Menu) { gameStates.menuController.MainMenu.Draw() }\n    }\n    gameStates.background.DrawToolBar()\n    this.DrawToolBarButtons()\n  },\n  StoryModeDraw: function () {\n    if (gameStates.currentStoryModeState === storyModeStates.Playing || gameStates.currentStoryModeState === storyModeStates.Paused || (gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.levelController.CheckLocked())) {\n      this.LevelsDraw()\n    }\n\n    if (gameStates.currentStoryModeState === storyModeStates.Selecting) { this.DrawSelectLevel() }\n    // this.DrawRules()\n\n    if (gameStates.currentStoryModeState === storyModeStates.WonStage) {\n      gameStates.menuController.WinMenu.Draw()\n      this.DrawFinishText()\n      return\n    }\n\n    if (gameStates.currentStoryModeState === storyModeStates.Lost) {\n      gameStates.menuController.LoseMenu.Draw()\n      this.DrawLoseText()\n    }\n\n    if (gameStates.currentStoryModeState === storyModeStates.Paused) {\n      canvas.context.fillStyle = 'rgba(128, 128, 128, 0.6)'\n      canvas.context.fillRect(0, 0, 850, 600)\n      gameStates.menuController.PauseMenu.Draw()\n    }\n  },\n  ShopDraw: function () {\n    if (gameStates.currentShopMode === ShopMode.ShopMenu) { gameStates.menuController.ShopMenu.Draw() }\n  },\n  StartingSreenDraw: function () {\n    this.ChangeShdow(8, 8, 'rgb(50, 50, 50)')\n\n    canvas.context.font = '275px Arial'\n    canvas.context.fillStyle = 'black'\n    canvas.context.fillText('CUB', 0, 250)\n    canvas.context.font = '125px Arial'\n    canvas.context.shadowColor = 'rgba(127, 0, 0)'\n    canvas.context.shadowOffsetX = 0\n    canvas.context.shadowOffsetY = 0\n    canvas.context.fillStyle = 'red'\n    canvas.context.fillText('Adventure', 120, 400)\n    canvas.context.font = '60px Arial'\n    canvas.context.fillStyle = 'darkred'\n    canvas.context.shadowColor = 'rgba(67, 0, 0)'\n    canvas.context.fillText('Press Enter to Begin', 120, 550)\n    ///\n    this.ChangeShdow(8, 8, 'rgb(50, 50, 50)')\n    canvas.context.fillStyle = 'black'\n    canvas.context.fillRect(600, 50, 200, 200)\n    this.ChangeShdow(0, 0, 'rgb(0, 0, 0)')\n    canvas.context.fillStyle = gameStates.currentThemeColour\n    canvas.context.fillRect(600 + 20, 50 + 40, 40, 40)\n    canvas.context.fillRect(600 + 140, 50 + 40, 40, 40)\n    canvas.context.fillRect(600 + 20, 50 + 130, 160, 40)\n  },\n  LevelsDraw: function () {\n    canvas.context.save()\n    canvas.context.translate(0 - 850 * (gameStates.CurrentLevel().currentX - 1), 0 - 600 * (gameStates.CurrentLevel().currentY - 1))\n    gameStates.CurrentLevel().waters.forEach(function (water) {\n      water.Draw()\n    })\n\n    gameStates.CurrentLevel().finishAreas.forEach(function (finishArea) {\n      finishArea.Draw()\n    })\n\n    gameStates.CurrentLevel().holes.forEach(function (hole) {\n      hole.Draw()\n    })\n\n    gameStates.CurrentLevel().unlocks.forEach(function (unlock) {\n      unlock.Draw()\n    })\n\n    gameStates.CurrentLevel().teleporters.forEach(function (teleporter) {\n      teleporter.Draw()\n    })\n\n    gameStates.CurrentLevel().items.forEach(function (item) {\n      item.Draw()\n    })\n\n    gameStates.CurrentLevel().rocks.forEach(function (rock) {\n      rock.Draw()\n    })\n\n    /* gameStates.CurrentLevel().changeDirectionSquares.forEach(function(changeDirectionSquare) {\n            changeDirectionSquare.Draw()\n        },) */\n\n    gameStates.CurrentLevel().players.forEach(function (player) {\n      player.Draw()\n    })\n\n    gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n      enemy.Draw()\n    })\n\n    gameStates.CurrentLevel().walls.forEach(function (wall) {\n      wall.Draw()\n    })\n    canvas.context.restore()\n  },\n  DrawRules: function () {\n    canvas.context.font = '175px Arial'\n    canvas.context.fillStyle = 'purple'\n    canvas.context.fillText('Rules', 200, 175)\n    ///\n    canvas.context.font = '45px Arial'\n    canvas.context.fillStyle = 'rgb(2, 0, 139)'\n    canvas.context.fillText('Get to the pink to beat levels', 150, 275)\n    canvas.context.fillText('Watch out for enemies', 200, 350)\n    if (!gameStates.mobile) {\n      canvas.context.fillText('Use A, W, S, D or Arrow Keys to move', 50, 425)\n    } else if (gameStates.mobile) {\n      canvas.context.font = '35px Arial'\n      canvas.context.fillText('Tap above, below, to the left or to the right to move', 35, 415)\n    }\n    canvas.context.font = '75px Arial'\n    canvas.context.fillStyle = 'blue'\n    canvas.context.fillText('Press space to start', 80, 550)\n  },\n  DrawFinishText: function () {\n    canvas.context.font = '88px Arial'\n    canvas.context.fillStyle = 'red'\n    canvas.context.fillText('Level ' + (gameStates.currentLevelIndex + 1) + ' Complete!', 60, 100)\n  },\n  DrawLoseText: function () {\n    canvas.context.font = '130px Arial'\n    canvas.context.fillStyle = 'darkorchid'\n    canvas.context.fillText('You Lose', 10, 120)\n    canvas.context.font = '75px Arial'\n    canvas.context.fillStyle = 'darkmagenta'\n    canvas.context.fillText('Losses', 575, 75)\n    canvas.context.fillText((levelTools.currentLosses), 675, 150)\n  },\n  DrawSelectLevel: function () {\n    canvas.context.font = '125px Arial'\n    canvas.context.fillStyle = 'rgba(255, 255, 132, 0.788)'\n    canvas.context.fillText('Level ' + (gameStates.currentLevelIndex + 1), 225, 575)\n    if (!gameStates.levelController.CheckLocked()) {\n      canvas.context.font = '175px Arial'\n      canvas.context.fillStyle = 'rgba(255, 255, 132)'\n      canvas.context.fillText('Locked', 10, 275)\n      draw.DrawImage(images.LockedIcon, 562.5, 10)\n    }\n    if (gameStates.mobile === true) {\n      draw.DrawImage(images.UpArrow, 10, 450)\n      draw.DrawImage(images.DownArrow, 690, 450)\n    }\n  },\n  SettingsDraw: function () {\n    if (gameStates.currentSettingState === settingStates.Selecting) { gameStates.menuController.SettingsMenu.Draw() }\n\n    if (gameStates.keybindController.seletingKeybind === true) {\n      this.DrawRebindingText()\n    } else if (gameStates.currentSettingState === settingStates.Keybinds) {\n      gameStates.menuController.KeybindsSelector.Draw()\n      gameStates.keybindController.keybinds.forEach(function (keybind) {\n        keybind.Draw()\n      })\n    }\n  },\n  DrawCharts: function () {\n    let numberDrew = 0\n    for (let col = 0; col < gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].loopHeight; col++) {\n      for (let row = 0; row < gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].loopWidth; row++) {\n        gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].items[numberDrew].Draw(row, col)\n        numberDrew++\n      }\n    }\n    numberDrew = 0\n    gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].Draw()\n  },\n  DrawRebindingText: function () {\n    // Set Alignment\n    canvas.context.textAlign = 'center'\n    // Set font and size\n    canvas.context.font = '80px Arial'\n    // Set font colour\n    canvas.context.fillStyle = 'rgb(97, 97, 117)'\n    // Draw text\n    canvas.context.fillText('Select an unused key', 410, 120)\n    canvas.context.fillText('to replace:', 410, 220)\n    canvas.context.fillStyle = gameStates.currentThemeColour\n    canvas.context.font = '80px Arial'\n    canvas.context.shadowColor = 'black'\n    canvas.context.shadowOffsetX = 5\n    canvas.context.shadowOffsetY = 5\n    switch (gameStates.keybindController.currentType) {\n      case 'A':\n        canvas.context.fillStyle = gameStates.currentThemeColour\n        canvas.context.fillText(gameStates.keybindController.currentKeybind.displayNameA, 410, 320)\n        canvas.context.shadowOffsetX = 0\n        canvas.context.shadowOffsetY = 0\n        canvas.context.strokeText(gameStates.keybindController.currentKeybind.displayNameA, 410, 320)\n        break\n\n      case 'B':\n\n        canvas.context.fillText(gameStates.keybindController.currentKeybind.displayNameB, 410, 320)\n        canvas.context.shadowOffsetX = 0\n        canvas.context.shadowOffsetY = 0\n        canvas.context.strokeText(gameStates.keybindController.currentKeybind.displayNameB, 410, 320)\n        break\n    }\n    canvas.context.shadowOffsetX = 0\n    canvas.context.shadowOffsetY = 0\n    canvas.context.fillStyle = 'rgb(97, 97, 117)'\n    if (gameStates.keybindController.triedRebinding) { canvas.context.fillText('Try Again', 410, 420) }\n    canvas.context.font = '60px Arial'\n    canvas.context.fillText('Click the back arrow to exit', 410, 575)\n    // Reset Alignment\n    canvas.context.textAlign = 'left'\n  },\n  DrawToolBarButtons: function () {\n    canvas.context.shadowOffsetX = 4\n    canvas.context.shadowOffsetY = 4\n    canvas.context.shadowColor = 'rgba(50, 50, 50)'\n    switch (gameStates.currentStoryModeState) {\n      case storyModeStates.Playing:\n        draw.DrawImage(images.PauseButton, 900, 475)\n        break\n\n      case storyModeStates.Paused:\n        draw.DrawImage(images.PlayButton, 900, 475)\n        break\n\n      default:\n        if (gameStates.currentStoryModeState !== storyModeStates.Lost && gameStates.currentStoryModeState !== storyModeStates.WonStage && gameStates.currentStartingMenusState !== startingMenusStates.NotStarted) { draw.DrawImage(images.BackButton, 900, 475) }\n        break\n    }\n    canvas.context.shadowOffsetX = 0\n    canvas.context.shadowOffsetY = 0\n    canvas.context.shadowColor = 'black'\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/drawing/Draw.js?");

/***/ }),

/***/ "./files/drawing/Images.js":
/*!*********************************!*\
  !*** ./files/drawing/Images.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"images\": () => (/* binding */ images)\n/* harmony export */ });\n\nconst images = {\n  stillLoading: 0,\n  LoadImages: function () {\n    ///\n    images.WallGrassClassicA = LoadImage('images/WallGrassClassicA.png')\n    images.WallGrassClassicB = LoadImage('images/WallGrassClassicB.png')\n    images.WallGrassClassicA_200x200 = LoadImage('images/WallGrassClassicA_200x200.png')\n    images.WallGrassClassicA_400x400 = LoadImage('images/WallGrassClassicA_400x400.png')\n    images.WallGrassRockA = LoadImage('images/WallGrassRockA.png')\n    images.WallGrassPuddleA = LoadImage('images/WallGrassPuddleA.png')\n    images.WallGrassTree = LoadImage('images/WallGrassTree.png')\n    images.WallGrassTreeV2 = LoadImage('images/WallGrassTreeV2.png')\n    ///\n    images.BlueCube = LoadImage('images/BlueCube.png')\n    images.BlueCubePyro = LoadImage('images/BlueCubePyro.png')\n    images.BlueCubeWooden = LoadImage('images/BlueCubeWooden.png')\n    images.BlueCubePoison = LoadImage('images/BlueCubePoison.png')\n    ///\n    images.BlueCubePlastic = LoadImage('images/BlueCubePlastic.png')\n    images.BlueCubePyroPlastic = LoadImage('images/BlueCubePyroPlastic.png')\n    images.BlueCubeWoodenPlastic = LoadImage('images/BlueCubeWoodenPlastic.png')\n    images.BlueCubePoisonPlastic = LoadImage('images/BlueCubePoisonPlastic.png')\n    ///\n    images.BlueCube_400x400 = LoadImage('images/BlueCube_400x400.png')\n    ///\n    images.RedCube = LoadImage('images/RedCube.png')\n    images.RedCube_200x200 = LoadImage('images/RedCube_200x200.png')\n    images.RedCubePlastic = LoadImage('images/RedCubePlastic.png')\n    ///\n    images.TeleporterTomato = LoadImage('images/TeleporterTomato.png')\n    images.TeleporterTomatoSprite = LoadImage('images/TeleporterTomatoSprite.png')\n    images.TeleporterTomatoSprite_200x200 = LoadImage('images/TeleporterTomatoSprite_200x200.png')\n    images.TeleporterPurple = LoadImage('images/TeleporterPurple.png')\n    images.TeleporterPurpleSprite = LoadImage('images/TeleporterPurpleSprite.png')\n    ///\n    images.SwitchW1Blue = LoadImage('images/SwitchW1Blue.png')\n    images.SwitchW1Blue_200x200 = LoadImage('images/SwitchW1Blue_200x200.png')\n    images.SwitchW1Purple = LoadImage('images/SwitchW1Purple.png')\n    images.SwitchW1Purple_200x200 = LoadImage('images/SwitchW1Purple_200x200.png')\n    images.SwitchW1ActivatedBlue = LoadImage('images/SwitchW1ActivatedBlue.png')\n    images.SwitchW1ActivatedPurple = LoadImage('images/SwitchW1ActivatedPurple.png')\n    ///\n    images.InvisibleWall = LoadImage('images/InvisibleWall.png')\n    images.InvisibleWallV2 = LoadImage('images/InvisibleWallV2.png')\n    images.InvisibleWall_200x200 = LoadImage('images/InvisibleWall_200x200.png')\n    ///\n    images.LifeJacket = LoadImage('images/LifeJacket.png')\n    images.LifeJacket_200x200 = LoadImage('images/LifeJacket_200x200.png')\n    images.LifeJacketPlastic = LoadImage('images/LifeJacketPlastic.png')\n    ///\n    images.Three_Bead = LoadImage('images/Three_Bead.png')\n    images.Three_Bead_Plastic = LoadImage('images/Three_Bead_Plastic.png')\n    ///\n    images.Water_Medium2 = LoadImage('images/Water_Medium2.png')\n    images.Water_Medium_200x200 = LoadImage('images/Water_Medium_200x200.png')\n    ///\n    images.UnlockRockPurple = LoadImage('images/UnlockRockPurple.png')\n    images.UnlockRockPurple_200x200 = LoadImage('images/UnlockRockPurple_200x200.png')\n    images.UnlockedRockPurple = LoadImage('images/UnlockedRockPurple.png')\n    images.UnlockRockBlue = LoadImage('images/UnlockRockBlue.png')\n    images.UnlockRockBlue_200x200 = LoadImage('images/UnlockRockBlue_200x200.png')\n    images.UnlockedRockBlue = LoadImage('images/UnlockedRockBlue.png')\n    ///\n    images.Hole = LoadImage('images/Hole.png')\n    images.Hole_200x200 = LoadImage('images/Hole_200x200.png')\n    images.HolePlastic = LoadImage('images/HolePlastic.png')\n    ///\n    images.UpArrow = LoadImage('images/UpArrow.png')\n    images.DownArrow = LoadImage('images/DownArrow.png')\n    images.UpArrowShop = LoadImage('images/UpArrowShop.png')\n    images.DownArrowShop = LoadImage('images/DownArrowShop.png')\n    images.LockedIcon = LoadImage('images/LockedIcon.png')\n    ///\n    images.BackButton = LoadImage('images/BackButton.png')\n    images.PauseButton = LoadImage('images/PauseButton.png')\n    images.PlayButton = LoadImage('images/PlayButton.png')\n  }\n}\n\nfunction LoadImage (path) {\n  const image = new window.Image()\n  image.src = path\n  images.stillLoading += 1\n  image.onload = function () {\n    images.stillLoading -= 1\n  }\n  return image\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/drawing/Images.js?");

/***/ }),

/***/ "./files/events/Keybinds.js":
/*!**********************************!*\
  !*** ./files/events/Keybinds.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Keybind\": () => (/* binding */ Keybind),\n/* harmony export */   \"KeybindController\": () => (/* binding */ KeybindController)\n/* harmony export */ });\n\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nconst { gameStates } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\n\nclass KeybindController {\n  constructor () {\n    this.keybinds = [\n      new Keybind('Left', 1, 'ArrowLeft', 'a'),\n      new Keybind('Right', 2, 'ArrowRight', 'd'),\n      new Keybind('Up', 3, 'ArrowUp', 'w'),\n      new Keybind('Down', 4, 'ArrowDown', 's'),\n      new Keybind('Select', 5, ' ', 'Enter', 'Space'),\n      new Keybind('Back', 6, 'Backspace', 'b'),\n      new Keybind('Use', 7, 'Shift', 'u')\n    ]\n\n    this.originalKeybinds = [\n      new Keybind('Left', 1, 'ArrowLeft', 'a'),\n      new Keybind('Right', 2, 'ArrowRight', 'd'),\n      new Keybind('Up', 3, 'ArrowUp', 'w'),\n      new Keybind('Down', 4, 'ArrowDown', 's'),\n      new Keybind('Select', 5, ' ', 'Enter', 'Space'),\n      new Keybind('Back', 6, 'Backspace', 'b'),\n      new Keybind('Use', 7, 'Shift', 'u')\n    ]\n    this.seletingKeybind = false\n    this.triedRebinding = false\n    this.currentMenuItem = undefined\n    this.currentKeybind = undefined\n    this.currentType = undefined\n  }\n\n  startRebind (type, keybindNumber, usedMenuItem) {\n    this.seletingKeybind = true\n    this.currentKeybind = this.keybinds[keybindNumber - 1]\n    this.currentMenuItem = usedMenuItem\n    this.currentType = type\n  }\n\n  setKeybinds (event) {\n    if (this.checkKeybinds(event.key)) {\n      switch (this.currentType) {\n        case 'A':\n          if (event.key === ' ') { this.currentKeybind.displayNameA = 'Space' } else { this.currentKeybind.displayNameA = event.key }\n          ///\n          this.currentKeybind.keybindA = event.key\n          this.currentMenuItem.title = this.currentKeybind.displayNameA\n          break\n        case 'B':\n          if (event.key === ' ') { this.currentKeybind.displayNameB = 'Space' } else { this.currentKeybind.displayNameB = event.key }\n          ///\n          this.currentKeybind.keybindB = event.key\n          this.currentMenuItem.title = this.currentKeybind.displayNameB\n          break\n      }\n      this.finishRebinding()\n    } else {\n      this.triedRebinding = true\n    }\n  }\n\n  checkKeybinds (keybind) {\n    for (let keybindNumber = 0; keybindNumber !== this.keybinds.length; keybindNumber++) {\n      if (keybind === this.keybinds[keybindNumber].keybindA || keybind === this.keybinds[keybindNumber].keybindB) {\n        return false\n      }\n    }\n    return true\n  }\n\n  finishRebinding () {\n    this.seletingKeybind = false\n    this.triedRebinding = false\n    this.currentMenuItem = undefined\n    this.currentKeybind = undefined\n    this.currentType = undefined\n  }\n\n  resetKeybinds (type) {\n    for (let keybindNumber = 0; keybindNumber !== this.keybinds.length; keybindNumber++) {\n      switch (type) {\n        case 'A':\n          this.keybinds[keybindNumber].keybindA = this.originalKeybinds[keybindNumber].keybindA\n          this.keybinds[keybindNumber].displayNameA = this.originalKeybinds[keybindNumber].displayNameA\n          break\n\n        case 'B':\n          this.keybinds[keybindNumber].keybindB = this.originalKeybinds[keybindNumber].keybindB\n          this.keybinds[keybindNumber].displayNameB = this.originalKeybinds[keybindNumber].displayNameB\n          break\n      }\n    }\n  }\n\n  load (savedArray) {\n    this.keybinds = []\n    for (let keybindsLoaded = 0; keybindsLoaded < 7; keybindsLoaded++) {\n      this.keybinds.push(new Keybind(savedArray[keybindsLoaded].name, savedArray[keybindsLoaded].value, savedArray[keybindsLoaded].keybindA, savedArray[keybindsLoaded].keybindB, savedArray[keybindsLoaded].displayNameA, savedArray[keybindsLoaded].displayNameB))\n    }\n  }\n}\n\nclass Keybind {\n  constructor (name, value, keybindA, keybindB, displayNameA, displayNameB) {\n    this.name = name\n\n    if (displayNameA === undefined) { this.displayNameA = keybindA } else { this.displayNameA = displayNameA }\n\n    ///\n\n    if (displayNameB === undefined) { this.displayNameB = keybindB } else { this.displayNameB = displayNameB }\n\n    this.keybindA = keybindA\n    this.keybindB = keybindB\n    this.x = 10\n    this.y = value * 75 - 15\n    this.value = value\n  }\n\n  Draw () {\n    canvas.context.font = '100px'\n    canvas.context.fillStyle = 'darkgray'\n    canvas.context.fillText(this.name, this.x, this.y)\n    canvas.context.fillText('Reset', this.x, 8 * 75 - 15)\n  }\n\n  Update () {\n    gameStates.menuController.menus[2].menuItems[this.value - 1].title = this.displayNameA\n    gameStates.menuController.menus[2].menuItems[this.value + 7].title = this.displayNameB\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/events/Keybinds.js?");

/***/ }),

/***/ "./files/events/Keydown.js":
/*!*********************************!*\
  !*** ./files/events/Keydown.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyUp\": () => (/* binding */ KeyUp),\n/* harmony export */   \"Keydown\": () => (/* binding */ Keydown)\n/* harmony export */ });\n\nconst { startingMenusStates, storyModeStates, gameMode, ShopMode, settingStates, gameStates} = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nfunction Keydown (event) {\n  console.log(event)\n  const keybindArray = gameStates.keybindController.keybinds\n  // Start Game \"Menu\"\n  if ((keybindArray[4/* select */].keybindA === event.key || keybindArray[4/* select */].keybindB === event.key) && gameStates.currentStartingMenusState === startingMenusStates.NotStarted) {\n    gameStates.SetGameState(startingMenusStates.Menu, 'Starting')\n    return\n  }\n\n  if ((keybindArray[5/* back */].keybindA === event.key || keybindArray[5/* back */].keybindB === event.key) && (gameStates.currentStartingMenusState === startingMenusStates.Menu || gameStates.currentStartingMenusState === startingMenusStates.Selected) && !gameStates.keybindController.seletingKeybind) {\n    if (gameStates.currentShopMode > 1) {\n      gameStates.currentShopMode = ShopMode.ShopMenu\n      return\n    }\n\n    if (gameStates.currentSettingState > 1) {\n      gameStates.SetGameState(settingStates.Selecting, 'Settings')\n      return\n    } else if (gameStates.currentStartingMenusState >= startingMenusStates.Menu && gameStates.currentStoryModeState === storyModeStates.Selecting) {\n      gameStates.SetGameState(gameStates.currentStartingMenusState - 1, 'Starting')\n      return\n    }\n  }\n  if (gameStates.menuController.CheckMenu() !== undefined) {\n    gameStates.menuController.menus[gameStates.menuController.CheckMenu()].Keydown(event, keybindArray, stopEvents)\n    return\n  }\n  \n  if (gameStates.currentStartingMenusState === startingMenusStates.Selected) {\n    // Down \"Level Selector\"\n    if ((keybindArray[3/* down */].keybindA === event.key || keybindArray[3/* down */].keybindB === event.key) && gameStates.currentLevelIndex < gameStates.levelController.levels.length - 1 && gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.currentGameMode === gameMode.StoryMode) { gameStates.currentLevelIndex = gameStates.currentLevelIndex + 1 }\n\n    // Up \"Level Selector\"\n    if ((keybindArray[2/* up */].keybindA === event.key || keybindArray[2/* up */].keybindB === event.key) && gameStates.currentLevelIndex !== 0 && gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.currentGameMode === gameMode.StoryMode) { gameStates.currentLevelIndex = gameStates.currentLevelIndex - 1 }\n\n    // Level Selector to Game\n    if ((keybindArray[4/* select */].keybindA === event.key || keybindArray[4/* select */].keybindB === event.key) && gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.currentGameMode === gameMode.StoryMode && gameStates.levelController.CheckLocked()) {\n      gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n      return\n    }\n    ///\n    if (gameStates.currentGameMode === gameMode.ItemsInfo) {\n      gameStates.infoController.Keydown(event, keybindArray)\n    }\n    ///\n    // Game to Pause Menu\n    if ((keybindArray[4/* select */].keybindA === event.key || keybindArray[4/* select */].keybindB === event.key) && gameStates.currentStoryModeState === storyModeStates.Playing && gameStates.currentGameMode === gameMode.StoryMode) {\n      gameStates.SetGameState(storyModeStates.Paused, 'StoryMode')\n      gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n        enemy.stopTimer()\n      })\n      return\n    }\n\n    if (gameStates.arrayChartController.findCurrentArrayChart() !== false) {\n      gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()].Keydown(event, keybindArray)\n    }\n\n    if (gameStates.currentStoryModeState === storyModeStates.Playing && gameStates.currentGameMode === gameMode.StoryMode) {\n      gameStates.CurrentLevel().players.forEach(function (player) {\n        player.Keydown(event, keybindArray)\n        player.changeSlideVariables()\n      })\n    }\n  }\n}\n\nconst stopEvents = {\n  stopMouseUp: false\n}\nfunction KeyUp (event) {\n  //console.log(event)\n  if (stopEvents.stopMouseUp === true) {\n    stopEvents.stopMouseUp = false\n    return\n  }\n  if (!gameStates.loading) {\n    if (gameStates.keybindController.seletingKeybind) { gameStates.keybindController.setKeybinds(event) }\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/events/Keydown.js?");

/***/ }),

/***/ "./files/events/MouseDown.js":
/*!***********************************!*\
  !*** ./files/events/MouseDown.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MouseDown\": () => (/* binding */ MouseDown)\n/* harmony export */ });\n\nconst { startingMenusStates, storyModeStates, gameMode, ShopMode, settingStates, gameStates } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\n\nfunction MouseDown (event) {\n  const isTouching = function (x, y, width, height, mouseX, mouseY) {\n    const boxLeft = x\n    const boxRight = x + width\n    const boxTop = y\n    const boxBottom = y + height\n    ///\n    if (mouseX >= boxLeft && mouseX <= boxRight &&\n            mouseY >= boxTop && mouseY <= boxBottom) {\n      return true\n    }\n    return false\n  }\n\n  // Start Game \"Menu\"\n  if (gameStates.currentStartingMenusState === startingMenusStates.NotStarted && isTouching(0, 500, 850, 100, event.offsetX, event.offsetY)) {\n    gameStates.SetGameState(startingMenusStates.Menu, 'Starting')\n    return\n  }\n\n  if (isTouching(900, 475, 100, 100, event.offsetX, event.offsetY)) {\n    if (gameStates.currentGameMode === gameMode.StoryMode && gameStates.currentStoryModeState === storyModeStates.Playing) {\n      gameStates.SetGameState(storyModeStates.Paused, 'StoryMode')\n      gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n        window.clearTimeout(enemy.timeoutID)\n        enemy.pausedDate = new Date()\n      })\n      return\n    }\n\n    if (gameStates.currentGameMode === gameMode.StoryMode && gameStates.currentStoryModeState === storyModeStates.Paused) {\n      gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n      gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n        enemy.setTimer()\n      })\n      return\n    } else if (gameStates.currentShopMode > 1) {\n      gameStates.currentShopMode = ShopMode.ShopMenu\n      return\n    } else if (gameStates.currentSettingState > 1) {\n      switch (gameStates.keybindController.seletingKeybind) {\n        case true:\n          gameStates.keybindController.finishRebinding()\n          break\n\n        case false:\n          gameStates.currentSettingState = settingStates.Selecting\n          break\n      }\n      return\n    } else if (gameStates.currentStartingMenusState >= startingMenusStates.Menu && gameStates.currentStoryModeState === storyModeStates.Selecting) {\n      gameStates.SetGameState(gameStates.currentStartingMenusState - 1, 'Starting')\n      return\n    }\n  }\n  if (gameStates.arrayChartController.findCurrentArrayChart() !== false) {\n    const arrayChart = gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()]\n    for (let numberChecked = 0; numberChecked < arrayChart.items.length; numberChecked++) {\n      if (isTouching(arrayChart.items[numberChecked].x, arrayChart.items[numberChecked].y, arrayChart.sectionWidth, arrayChart.sectionHeight, event.offsetX, event.offsetY)) {\n        arrayChart.action(arrayChart, numberChecked)\n      }\n    }\n  }\n\n  // Left \"Menus\"\n  if (isTouching(0, gameStates.selectorY, gameStates.selectorX, gameStates.selectorYBottom - gameStates.selectorY, event.offsetX, event.offsetY) && gameStates.menuController.CheckMenu() !== undefined) { gameStates.menuController.menus[gameStates.menuController.CheckMenu()].moveLeft() }\n\n  // Right \"Menus\"\n  if (isTouching(gameStates.selectorXBottom + 1, gameStates.selectorY, 850 - gameStates.selectorXBottom, gameStates.selectorYBottom - gameStates.selectorY, event.offsetX, event.offsetY) && gameStates.menuController.CheckMenu() !== undefined) { gameStates.menuController.menus[gameStates.menuController.CheckMenu()].moveRight() }\n\n  // Down \"Menus\"\n  if (isTouching(gameStates.selectorX, gameStates.selectorYBottom + 1, gameStates.selectorXBottom - gameStates.selectorX, 600 - gameStates.selectorYBottom, event.offsetX, event.offsetY) && gameStates.menuController.CheckMenu() !== undefined) { gameStates.menuController.menus[gameStates.menuController.CheckMenu()].moveDown() }\n\n  // Up \"Menus\"\n  if (isTouching(gameStates.selectorX, 0, gameStates.selectorXBottom - gameStates.selectorX, gameStates.selectorY, event.offsetX, event.offsetY) && gameStates.menuController.CheckMenu() !== undefined) { gameStates.menuController.menus[gameStates.menuController.CheckMenu()].moveUp() }\n\n  // Selected \"Menus\"\n  if (isTouching(gameStates.selectorX, gameStates.selectorY - 1, gameStates.selectorXBottom - gameStates.selectorX, gameStates.selectorYBottom - gameStates.selectorY, event.offsetX, event.offsetY) && gameStates.menuController.CheckMenu() !== undefined) {\n    gameStates.menuController.menus[gameStates.menuController.CheckMenu()].selected()\n    return\n  }\n\n  if (gameStates.currentStartingMenusState === startingMenusStates.Selected) {\n    // Down \"Level Selector\"\n    if (gameStates.currentLevelIndex < gameStates.levelController.levels.length - 1 && gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.currentGameMode === gameMode.StoryMode && event.offsetX < 850 && event.offsetX > 690 && event.offsetY > 450 && event.offsetY < 600 && gameStates.mobile === true) { gameStates.currentLevelIndex = gameStates.currentLevelIndex + 1 }\n\n    // Up \"Level Selector\"\n    if (gameStates.currentLevelIndex !== 0 && gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.currentGameMode === gameMode.StoryMode && event.offsetX < 160 && event.offsetX > 0 && event.offsetY > 450 && event.offsetY < 600 && gameStates.mobile === true) { gameStates.currentLevelIndex = gameStates.currentLevelIndex - 1 }\n\n    // Level Selector to Game\n    if (gameStates.currentStoryModeState === storyModeStates.Selecting && gameStates.currentGameMode === gameMode.StoryMode && event.offsetY > 500 && event.offsetY < 600 && event.offsetX < 610 && event.offsetX > 225) {\n      gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n      return\n    }\n\n    if (gameStates.currentGameMode === gameMode.ItemsInfo) {\n      gameStates.infoController.Mousedown(event)\n    }\n\n    if (gameStates.currentStoryModeState === storyModeStates.Playing && gameStates.currentGameMode === gameMode.StoryMode) {\n      gameStates.CurrentLevel().players.forEach(function (player) {\n        const leftOffset = player.x + player.width / 2 - 850 * (gameStates.CurrentLevel().currentX - 1) - event.offsetX\n        const rightOffset = event.offsetX - (player.x + player.width / 2 - 850 * (gameStates.CurrentLevel().currentX - 1))\n        const topOffset = player.y + player.height / 2 - 600 * (gameStates.CurrentLevel().currentY - 1) - event.offsetY\n        const bottomOffset = event.offsetY - (player.y + player.height / 2 - 600 * (gameStates.CurrentLevel().currentY - 1))\n        if (leftOffset > rightOffset && leftOffset > topOffset && leftOffset > bottomOffset) {\n          player.moveLeft()\n          return\n        }\n        if (rightOffset > leftOffset && rightOffset > topOffset && rightOffset > bottomOffset) {\n          player.moveRight()\n          return\n        }\n        if (topOffset > bottomOffset && topOffset > leftOffset && topOffset > rightOffset) {\n          player.moveUp()\n          return\n        }\n        if (bottomOffset > topOffset && bottomOffset > leftOffset && bottomOffset > rightOffset) {\n          player.moveDown()\n        }\n      })\n    }\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/events/MouseDown.js?");

/***/ }),

/***/ "./files/levels/Barriers.js":
/*!**********************************!*\
  !*** ./files/levels/Barriers.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rock\": () => (/* binding */ Rock),\n/* harmony export */   \"Wall\": () => (/* binding */ Wall),\n/* harmony export */   \"Water\": () => (/* binding */ Water)\n/* harmony export */ });\n\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { draw } = __webpack_require__(/*! ../drawing/Draw */ \"./files/drawing/Draw.js\")\nconst { storyModeStates, gameStates, BackgroundStyles } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nconst { GameObject } = __webpack_require__(/*! ./Class */ \"./files/levels/Class.js\")\n  class Wall extends GameObject {\n    constructor (x, y, width, height, color1, allowMovement, invisibleWall) {\n      super(x, y, width, height, color1)\n      this.original_x = this.x\n      this.original_y = this.y\n      this.allowMovement = allowMovement\n      this.invisibleWall = invisibleWall\n      this.randomList = Array(100)\n      for (let i = 0; i < 100; i++) {\n        this.randomList[i] = Math.floor(Math.random() * 1000)\n      }\n    }\n  \n    Draw () {\n      if (this.invisibleWall && gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n        let i = 0\n        for (let x = this.left(); x < this.right(); x = x + 50) {\n          for (let y = this.top(); y < this.bottom(); y = y + 50) {\n            i++\n            canvas.context.save()\n            canvas.context.translate(x - 2, y - 2)\n            ///\n            if (this.randomList[i] % 15 === 0) { draw.DrawImage(images.InvisibleWallV2, 0, 0) } else { draw.DrawImage(images.InvisibleWall, 0, 0) }\n            canvas.context.restore()\n          }\n        }\n        /* } else if (this.x > 800) {\n              for (var x = this.left(); x < this.right(); x = x + 50) {\n                  for (var y = this.top(); y < this.bottom(); y = y + 50) {\n              draw.DrawImage(images.WallGrassEdgeY, )\n                  }\n              } */\n      } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic && !this.invisibleWall) {\n        let i = 0\n        for (let x = this.left(); x < this.right(); x += 50) {\n          for (let y = this.top(); y < this.bottom(); y += 50) {\n            i++\n            ///\n            canvas.context.save()\n            canvas.context.translate(x - 2, y - 2)\n            // if (this.randomList[i] % 2 === 0)\n            // canvas.context.rotate(90 * Math.PI / 180)\n            if (this.randomList[i] % 40 === 0) {\n              draw.DrawImage(images.WallGrassPuddleA, 0, 0)\n            } else if (this.randomList[i] % 9 === 0) { draw.DrawImage(images.WallGrassRockA, 0, 0) } else if (this.randomList[i] % 507 === 0) {\n              draw.DrawImage(images.WallGrassTree, 0, 0)\n            } else {\n              // if (Math.floor(Math.random() * 2 + 1) === 1)\n              draw.DrawImage(images.WallGrassClassicA, 0, 0)\n              // else\n            }\n  \n            canvas.context.restore()\n          }\n        }\n      } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n        canvas.context.fillStyle = this.color1\n        canvas.context.fillRect(this.x, this.y, this.width, this.height)\n      }\n    }\n  \n    reset () {\n      this.x = this.original_x\n      this.y = this.original_y\n    }\n  };\n  \n  class Water extends GameObject {\n    constructor (x, y, width, height, color1) {\n      super(x, y, width, height, color1)\n      this.original_x = this.x\n      this.original_y = this.y\n      this.spriteX = 0\n    }\n  \n    Draw () {\n      if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n        if (gameStates.currentStoryModeState === storyModeStates.Playing) {\n          const numMilliseconds = new Date().getTime()\n          if (numMilliseconds % 5 === 4) {\n            this.spriteX = (this.spriteX + 54) % (54 * 49)\n          }\n        }\n        for (let x = this.left(); x < this.right(); x = x + 50) {\n          for (let y = this.top(); y < this.bottom(); y = y + 50) {\n            canvas.context.drawImage(images.Water_Medium2, this.spriteX, 0, 54, images.Water_Medium2.height, x, y, 54, images.Water_Medium2.height)\n          }\n        }\n      }\n      if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n        canvas.context.fillStyle = this.color1\n        canvas.context.fillRect(this.x, this.y, this.width, this.height)\n      }\n    }\n  \n    Update () {\n  \n    }\n  \n    reset () {\n      this.x = this.original_x\n      this.y = this.original_y\n    }\n  };\n\n  class Rock extends GameObject {\n    constructor (x, y, width, height, color1, color2, title, allowMovement, colorNumber, typeNumber) {\n      super(x, y, width, height, color1)\n      this.original_x = this.x\n      this.original_y = this.y\n      this.color2 = color2\n      this.title = title\n      this.allowMovement = allowMovement\n      this.originalAllowMovement = this.allowMovement\n      this.colorNumber = colorNumber\n      this.typeNumber = typeNumber\n    }\n  \n    Draw () {\n      const self = this\n      if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic && this.typeNumber === 1) {\n        if (this.colorNumber === 1) {\n          gameStates.CurrentLevel().unlocks.forEach(function (unlock) {\n            if (self.allowMovement && unlock.title === self.title) {\n              draw.DrawImage(images.UnlockedRockBlue, self.x, self.y)\n            } else if (!self.allowMovement && unlock.title === self.title) {\n              draw.DrawImage(images.UnlockRockBlue, self.x, self.y)\n            }\n          })\n        } else if (this.colorNumber === 2) {\n          gameStates.CurrentLevel().unlocks.forEach(function (unlock) {\n            if (self.allowMovement && unlock.title === self.title) {\n              draw.DrawImage(images.UnlockedRockPurple, self.x, self.y)\n            } else if (!self.allowMovement && unlock.title === self.title) {\n              draw.DrawImage(images.UnlockRockPurple, self.x, self.y)\n            }\n          })\n        }\n      } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic && this.typeNumber === 1) {\n        gameStates.CurrentLevel().unlocks.forEach(function (unlock) {\n          if (!self.allowMovement && unlock.title === self.title) { canvas.context.fillStyle = self.color1 }\n  \n          if (self.allowMovement && unlock.title === self.title) { canvas.context.fillStyle = self.color2 }\n        })\n        canvas.context.beginPath()\n        canvas.context.arc(this.x + 25, this.y + 25, 25, 0, 360)\n        canvas.context.fill()\n      }\n    }\n  \n    reset () {\n      this.x = this.original_x\n      this.y = this.original_y\n      this.allowMovement = this.originalAllowMovement\n    }\n  };\n\n//# sourceURL=webpack://cube-adventure/./files/levels/Barriers.js?");

/***/ }),

/***/ "./files/levels/Class.js":
/*!*******************************!*\
  !*** ./files/levels/Class.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Background\": () => (/* binding */ Background),\n/* harmony export */   \"GameObject\": () => (/* binding */ GameObject)\n/* harmony export */ });\n\nconst { gameMode, startingMenusStates, storyModeStates, gameStates, BackgroundStyles } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nclass GameObject {\n  constructor (x, y, width, height, color1) {\n    this.x = x\n    this.y = y\n    this.width = width\n    this.height = height\n    this.color1 = color1\n  }\n\n  intersects (otherBox) {\n    // Check if the left-top point is inside otherBox\n    if (this.left() >= otherBox.left() && this.left() < otherBox.right() &&\n            this.top() >= otherBox.top() && this.top() < otherBox.bottom()) {\n      return true\n    }\n    // Check if the right-top point is inside otherBox\n    if (this.right() > otherBox.left() && this.right() < otherBox.right() &&\n            this.top() >= otherBox.top() && this.top() < otherBox.bottom()) {\n      return true\n    }\n    // Check if the right-bottom point is inside otherBox\n    if (this.right() > otherBox.left() && this.right() < otherBox.right() &&\n            this.bottom() > otherBox.top() && this.bottom() < otherBox.bottom()) {\n      return true\n    }\n\n    // Check if the left-bottom point is inside otherBox\n    if (this.left() >= otherBox.left() && this.left() < otherBox.right() &&\n            this.bottom() > otherBox.top() && this.bottom() < otherBox.bottom()) {\n      return true\n    }\n\n    /// /////////////////////\n\n    // Check if the left-top point is inside otherBox\n    if (otherBox.left() >= this.left() && otherBox.left() < this.right() &&\n            otherBox.top() >= this.top() && otherBox.top() < this.bottom()) {\n      return true\n    }\n    // Check if the right-top point is inside otherBox\n    if (otherBox.right() > this.left() && otherBox.right() < this.right() &&\n            otherBox.top() >= this.top() && otherBox.top() < this.bottom()) {\n      return true\n    }\n    // Check if the right-bottom point is inside otherBox\n    if (otherBox.right() > this.left() && otherBox.right() < this.right() &&\n            otherBox.bottom() > this.top() && otherBox.bottom() < this.bottom()) {\n      return true\n    }\n\n    // Check if the left-bottom point is inside otherBox\n    if (otherBox.left() >= this.left() && otherBox.left() < this.right() &&\n            otherBox.bottom() > this.top() && otherBox.bottom() < this.bottom()) {\n      return true\n    }\n\n    return false\n  }\n\n  intersectsAll (otherBox) {\n    // Check if the left-top point is inside otherBox\n    if (this.left() === otherBox.left() && this.top() === otherBox.top()) {\n      return true\n    }\n    return false\n  }\n\n  left () {\n    return this.x\n  }\n\n  right () {\n    return this.x + this.width\n  }\n\n  top () {\n    return this.y\n  }\n\n  bottom () {\n    return this.y + this.height\n  }\n\n  /* above(typeArray, itemX, itemY) {\n        typeArray.forEach(function(type) {\n            for (var x = type.left(); x < type.right(); x = x + 50) {\n                for (var y = type.top(); y < type.bottom(); y = y + 50) {\n                    if (x === itemX && y - 50 === itemY) {\n                        return true\n                    }\n                }\n            }\n\n        },)\n        return false\n    } */\n  changeSlideVariables () {\n    gameStates.CurrentLevel().players.forEach(function (player) {\n      if (player.x < 850 * (gameStates.CurrentLevel().currentX - 1)) {\n        if (gameStates.CurrentLevel().currentX !== 1) {\n          gameStates.CurrentLevel().currentX -= 1\n        } else {\n          player.x += 50\n        }\n        return\n      }\n\n      if (player.x > 850 * gameStates.CurrentLevel().currentX - 50) {\n        if (gameStates.CurrentLevel().currentX !== gameStates.CurrentLevel().width) {\n          gameStates.CurrentLevel().currentX += 1\n        } else {\n          player.x -= 50\n        }\n        return\n      }\n\n      if (player.y < 600 * (gameStates.CurrentLevel().currentY - 1)) {\n        if (gameStates.CurrentLevel().currentY !== 1) {\n          gameStates.CurrentLevel().currentY -= 1\n        } else {\n          player.y += 50\n        }\n        return\n      }\n\n      if (player.y > 600 * gameStates.CurrentLevel().currentY - 50) {\n        if (gameStates.CurrentLevel().currentY !== gameStates.CurrentLevel().height) {\n          gameStates.CurrentLevel().currentY += 1\n        } else {\n          player.y -= 50\n        }\n      }\n    })\n  }\n};\n\nclass Background {\n  constructor (color1, color2) {\n    this.color1 = color1\n    this.color2 = color2\n  }\n\n  DrawBackround () {\n    if ((gameStates.currentStoryModeState === storyModeStates.Playing || gameStates.currentStoryModeState === storyModeStates.Paused || gameStates.currentStoryModeState === storyModeStates.Selecting) && gameStates.currentGameMode === gameMode.StoryMode && gameStates.currentStartingMenusState === startingMenusStates.Selected && gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n      this.color1 = 'rgb(100, 200, 100)'\n    } else {\n      this.color1 = 'lightgray'\n    }\n\n    canvas.context.clearRect(0, 0, canvas.width, canvas.height)\n    canvas.context.fillStyle = this.color1\n    canvas.context.fillRect(0, 0, canvas.width - 200, canvas.height)\n  }\n\n  DrawToolBar () {\n    this.color2 = gameStates.currentThemeColour\n    canvas.context.fillStyle = this.color2\n    canvas.context.fillRect(850, 0, 200, canvas.height)\n    canvas.context.fillStyle = 'black'\n    canvas.context.fillRect(850, 0, 2, canvas.height)\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://cube-adventure/./files/levels/Class.js?");

/***/ }),

/***/ "./files/levels/Collectable.js":
/*!*************************************!*\
  !*** ./files/levels/Collectable.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Item\": () => (/* binding */ Item)\n/* harmony export */ });\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { draw } = __webpack_require__(/*! ../drawing/Draw */ \"./files/drawing/Draw.js\")\nconst { gameMode, gameStates, BackgroundStyles, drawUpdate } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { GameObject } = __webpack_require__(/*! ./Class */ \"./files/levels/Class.js\")\nclass Item extends GameObject {\n    constructor (x, y, width, height, typeNumber) {\n      super(x, y, width, height)\n      this.original_x = this.x\n      this.original_y = this.y\n      this.typeNumber = typeNumber\n      this.allowMovementWater = false\n      this.collected = false\n    }\n  \n    Draw () {\n      if (this.typeNumber === 1 && !this.collected && gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n        draw.DrawImage(images.LifeJacket, this.x, this.y)\n      }\n  \n      if (this.typeNumber === 1 && !this.collected && gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n        draw.DrawImage(images.LifeJacketPlastic, this.x, this.y)\n      }\n  \n      if (this.typeNumber === 2 && !this.collected && gameStates.currentBackgroundStyle === BackgroundStyles.Classic && gameStates.currentGameMode === gameMode.StoryMode && drawUpdate.blueCubeAlienLock) {\n        draw.DrawImage(images.Three_Bead, this.x, this.y)\n      }\n  \n      if (this.typeNumber === 2 && !this.collected && gameStates.currentBackgroundStyle === BackgroundStyles.Plastic && gameStates.currentGameMode === gameMode.StoryMode && drawUpdate.blueCubeAlienLock) {\n        draw.DrawImage(images.Three_Bead_Plastic, this.x, this.y)\n      }\n    }\n  \n    update () {\n      if (this.typeNumber === 2 && this.collected && gameStates.currentGameMode === gameMode.StoryMode) {\n        drawUpdate.blueCubeAlienLock = false\n      }\n    }\n  \n    reset () {\n      this.x = this.original_x\n      this.y = this.original_y\n      this.allowMovementWater = false\n      this.collected = false\n    }\n  };\n\n//# sourceURL=webpack://cube-adventure/./files/levels/Collectable.js?");

/***/ }),

/***/ "./files/levels/Interactable.js":
/*!**************************************!*\
  !*** ./files/levels/Interactable.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FinishArea\": () => (/* binding */ FinishArea),\n/* harmony export */   \"Hole\": () => (/* binding */ Hole),\n/* harmony export */   \"Teleporter\": () => (/* binding */ Teleporter),\n/* harmony export */   \"Unlock\": () => (/* binding */ Unlock)\n/* harmony export */ });\n\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { draw } = __webpack_require__(/*! ../drawing/Draw */ \"./files/drawing/Draw.js\")\nconst {gameStates, BackgroundStyles} = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nconst { GameObject } = __webpack_require__(/*! ./Class */ \"./files/levels/Class.js\")\nclass Unlock extends GameObject {\n  constructor (x, y, width, height, color1, color2, activatedcolor, title, colorNumber) {\n    super(x, y, width, height, color1)\n    this.original_x = this.x\n    this.original_y = this.y\n    this.color2 = color2\n    this.activatedcolor = activatedcolor\n    this.title = title\n    this.colorNumber = colorNumber\n  }\n\n  update () {\n    const self = this\n    gameStates.CurrentLevel().players.forEach(function (player) {\n      if (self.intersectsAll(player)) {\n        gameStates.CurrentLevel().rocks.forEach(function (rock) {\n          if (self.title === rock.title && rock.allowMovement === rock.originalAllowMovement) {\n            rock.allowMovement = !rock.allowMovement\n          }\n        })\n        gameStates.CurrentLevel().changeDirectionSquares.forEach(function (changeDirectionSquare) {\n          if (self.title === changeDirectionSquare.title) {\n            changeDirectionSquare.allowDirectionChange = true\n          }\n        })\n        self.activated = true\n      }\n    })\n\n    gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n      if (self.intersectsAll(enemy)) {\n        gameStates.CurrentLevel().rocks.forEach(function (rock) {\n          if (self.title === rock.title && rock.allowMovement === rock.originalAllowMovement) {\n            rock.allowMovement = !rock.allowMovement\n          }\n        })\n        gameStates.CurrentLevel().changeDirectionSquares.forEach(function (changeDirectionSquare) {\n          if (self.title === changeDirectionSquare.title) {\n            changeDirectionSquare.allowDirectionChange = true\n          }\n        })\n        self.activated = true\n      }\n    })\n  }\n\n  Draw () {\n    if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n      if (this.colorNumber === 1) {\n        if (this.activated) { draw.DrawImage(images.SwitchW1ActivatedBlue, this.x, this.y) } else { draw.DrawImage(images.SwitchW1Blue, this.x, this.y) }\n      } else if (this.colorNumber === 2) {\n        if (this.activated) { draw.DrawImage(images.SwitchW1ActivatedPurple, this.x, this.y) } else { draw.DrawImage(images.SwitchW1Purple, this.x, this.y) }\n      }\n    } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n      canvas.context.fillStyle = this.color1\n      canvas.context.fillRect(this.x, this.y, this.width, this.height)\n      if (this.activated) { canvas.context.fillStyle = this.activatedcolor } else { canvas.context.fillStyle = this.color2 }\n      canvas.context.fillRect(this.x + 10, this.y + 10, 30, 30)\n    }\n  }\n\n  reset () {\n    this.x = this.original_x\n    this.y = this.original_y\n    this.activated = false\n  }\n};\n\nclass Teleporter extends GameObject {\n  constructor (x, y, width, height, teleportTo, colorNumber) {\n    super(x, y, width, height)\n    this.original_x = this.x\n    this.original_y = this.y\n    this.originalTeleportingX = undefined\n    this.originalTeleportingY = undefined\n    this.original_y = this.y\n    this.colorNumber = colorNumber\n    this.stop = false\n    this.teleportTo = teleportTo\n  }\n\n  update () {\n    const self = this\n    gameStates.CurrentLevel().players.forEach(function (player) {\n      gameStates.CurrentLevel().teleporters.forEach(function (teleporter) {\n        if (self.intersects(player) && !self.stop) {\n          if (self.teleportTo === teleporter.teleportTo && self.colorNumber === teleporter.colorNumber && self !== teleporter) {\n            teleporter.stop = true\n            player.y = teleporter.y\n            player.x = teleporter.x\n          }\n        }\n        if (!teleporter.intersects(player) && teleporter.stop) {\n          self.stop = false\n        }\n      })\n    })\n  }\n\n  Draw () {\n    if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n      if (this.colorNumber === 1) {\n        draw.DrawImage(images.TeleporterTomatoSprite, this.x, this.y)\n      }\n\n      if (this.colorNumber === 2) {\n        draw.DrawImage(images.TeleporterPurpleSprite, this.x, this.y)\n      }\n    } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n      if (this.colorNumber === 1) {\n        draw.DrawImage(images.TeleporterTomato, this.x, this.y)\n      }\n\n      if (this.colorNumber === 2) {\n        draw.DrawImage(images.TeleporterPurple, this.x, this.y)\n      }\n    }\n  }\n\n  reset () {\n    this.x = this.original_x\n    this.y = this.original_y\n  }\n};\n\nclass Hole extends GameObject {\n  constructor (x, y, width, height, fullHole, currentIntersects, maxIntersects) {\n    super(x, y, width, height)\n    this.original_x = this.x\n    this.original_y = this.y\n    this.fullHole = fullHole\n    this.currentIntersects = currentIntersects\n    this.originalCurrentIntersects = this.currentIntersects\n    this.maxIntersects = maxIntersects\n    this.previousIntersectsHole = false\n    this.stopPlayer = false\n    this.stopEnemy = false\n    this.DrawingX = undefined\n  }\n\n  Draw () {\n    if (this.fullHole) { this.DrawingX = 100 } else if (this.currentIntersects < this.maxIntersects && this.currentIntersects !== 0) { this.DrawingX = 50 } else { this.DrawingX = 0 }\n\n    if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n      canvas.context.drawImage(images.Hole, this.DrawingX, 0, 50, 50, this.x, this.y, this.width, this.height)\n    }\n\n    if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n      canvas.context.drawImage(images.HolePlastic, this.DrawingX, 0, 50, 50, this.x, this.y, this.width, this.height)\n    }\n  }\n\n  update () {\n    if (this.currentIntersects >= this.maxIntersects) {\n      this.fullHole = true\n    }\n  }\n\n  reset () {\n    this.x = this.original_x\n    this.y = this.original_y\n    this.fullHole = false\n    this.currentIntersects = this.originalCurrentIntersects\n  }\n}\n\nclass FinishArea extends GameObject {\n  constructor (x, y, width, height) {\n    super(x, y, width, height, 'pink')\n    this.original_x = this.x\n    this.original_y = this.y\n  }\n\n  Draw () {\n    canvas.context.fillStyle = this.color1\n    canvas.context.fillRect(this.x, this.y, this.width, this.height)\n  }\n\n  reset () {\n    this.x = this.original_x\n    this.y = this.original_y\n  }\n};\n\n\n//# sourceURL=webpack://cube-adventure/./files/levels/Interactable.js?");

/***/ }),

/***/ "./files/levels/Levels.js":
/*!********************************!*\
  !*** ./files/levels/Levels.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LevelController\": () => (/* binding */ LevelController)\n/* harmony export */ });\n\nconst { Player, Enemy, ChangeDirectionSquare } = __webpack_require__(/*! ./Moveable */ \"./files/levels/Moveable.js\")\nconst { Wall, Rock, Water } = __webpack_require__(/*! ./Barriers */ \"./files/levels/Barriers.js\")\nconst { Unlock, Teleporter, Hole, FinishArea } = __webpack_require__(/*! ./Interactable */ \"./files/levels/Interactable.js\")\nconst { Item } = __webpack_require__(/*! ./Collectable */ \"./files/levels/Collectable.js\")\nconst { gameStates } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\n\nclass Level {\n  constructor (levelData, requirement1, requirement2, currentX, currentY, width, height) {\n    this.players = levelData.players ?? []\n    this.enemies = levelData.enemies ?? []\n    this.walls = levelData.walls ?? []\n    this.waters = levelData.waters ?? []\n    this.items = levelData.items ?? []\n    this.rocks = levelData.rocks ?? []\n    this.holes = levelData.holes ?? []\n    this.finishAreas = levelData.finishAreas ?? []\n    this.changeDirectionSquares = levelData.changeDirectionSquares ?? []\n    this.unlocks = levelData.unlocks ?? []\n    this.teleporters = levelData.teleporters ?? []\n    this.requirement1 = requirement1\n    this.requirement2 = requirement2\n    this.currentX = currentX\n    this.startingX = this.currentX\n    this.currentY = currentY\n    this.startingY = this.currentY\n    this.width = width\n    this.height = height\n  }\n}\n\nclass LevelController {\n  constructor () {\n    this.levels = []\n  }\n\n  createLevels () {\n    // Level 1\n    this.levels.push(new Level({\n      players: [\n        new Player(400, 0, 50, 50)\n      ],\n      enemies: [\n        new Enemy(800, 400, 50, 50, false, true, false, false, 5),\n        new Enemy(0, 200, 50, 50, true, false, false, false, 5)\n      ],\n      finishAreas: [\n        new FinishArea(0, 550, 850, 50)\n      ]\n    }, /* Requirements */0, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 2\n    this.levels.push(new Level({\n      players: [\n        new Player(400, 0, 50, 50)\n      ],\n      enemies: [\n        new Enemy(400, 500, 50, 50, false, false, true, false, 3)\n      ],\n      walls: [\n        new Wall(0, 0, 350, 600, 'rgb(190, 190, 190)'),\n        new Wall(500, 0, 350, 600, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(350, 100, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(350, 250, 50, 200, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(450, 100, 50, 200, 'rgb(190, 190, 190)'),\n        new Wall(450, 400, 50, 50, 'rgb(190, 190, 190)')\n      ],\n      finishAreas: [\n        new FinishArea(350, 550, 150, 50)\n      ]\n    }, /* Requirements */1, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 3\n    this.levels.push(new Level({\n      players: [\n        new Player(400, 0, 50, 50)\n      ],\n      enemies: [\n        new Enemy(200, 450, 50, 50, true, false, false, false, 4),\n        new Enemy(400, 350, 50, 50, true, true, false, false, 2.5),\n        new Enemy(600, 50, 50, 50, false, true, false, false, 4)\n      ],\n      walls: [\n        new Wall(0, 0, 200, 550, 'rgb(190, 190, 190)'),\n        new Wall(650, 0, 200, 550, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(200, 0, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(500, 0, 150, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(500, 100, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(200, 100, 150, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(350, 200, 150, 150, 'rgb(190, 190, 190)'),\n        new Wall(550, 150, 100, 250, 'rgb(190, 190, 190)'),\n        new Wall(200, 150, 100, 250, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(0, 550, 350, 50, 'rgb(190, 190, 190)'),\n        new Wall(500, 550, 350, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(200, 400, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(500, 400, 150, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(200, 500, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(500, 500, 150, 50, 'rgb(190, 190, 190)')\n      ],\n      finishAreas: [\n        new FinishArea(350, 550, 150, 50)\n      ],\n      changeDirectionSquares: [\n        new ChangeDirectionSquare(300, 150, 50, 50, false, true, false, true, true),\n        ///\n        new ChangeDirectionSquare(500, 150, 50, 50, true, false, false, true, true),\n        ///\n        new ChangeDirectionSquare(300, 350, 50, 50, true, false, true, false, true),\n        ///\n        new ChangeDirectionSquare(500, 350, 50, 50, false, true, true, false, true)\n      ]\n    }, /* Requirements */2, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 4\n    this.levels.push(new Level({\n      players: [\n        new Player(100, 100, 50, 50)\n      ],\n      enemies: [\n        new Enemy(400, 50, 50, 50, true, true, false, false, 3),\n        ///\n        new Enemy(300, 300, 50, 50, true, false, false, false, 2.5),\n        new Enemy(300, 500, 50, 50, true, false, false, false, 2.5),\n        ///\n        new Enemy(500, 300, 50, 50, false, true, false, false, 2.5),\n        new Enemy(500, 500, 50, 50, false, true, false, false, 2.5)\n      ],\n      walls: [\n        new Wall(0, 0, 850, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(0, 50, 100, 550, 'rgb(190, 190, 190)'),\n        new Wall(750, 50, 100, 550, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(150, 100, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(450, 100, 250, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(0, 150, 400, 50, 'rgb(190, 190, 190)'),\n        new Wall(450, 150, 400, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(350, 200, 50, 350, 'rgb(190, 190, 190)'),\n        new Wall(450, 200, 50, 350, 'rgb(190, 190, 190)')\n      ],\n      rocks: [\n        new Rock(400, 500, 50, 50, 'lightblue', 'aqua', '4Blue', false, 1, 1)\n      ],\n      finishAreas: [\n        new FinishArea(100, 200, 250, 50),\n        new FinishArea(500, 200, 250, 50)\n      ],\n      unlocks: [\n        new Unlock(700, 100, 50, 50, 'rgb(180, 180, 180)', 'lightblue', 'aqua', '4Blue', 1)\n      ]\n    }, /* Requirements */3, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 5\n    this.levels.push(new Level({\n      players: [\n        new Player(150, 150, 50, 50)\n      ],\n      enemies: [\n        new Enemy(50, 500, 50, 50, false, false, true, false, 2.5),\n        new Enemy(500, 150, 50, 50, false, true, false, false, 2.5),\n        new Enemy(500, 300, 50, 50, false, true, false, false, 2.5),\n        new Enemy(500, 450, 50, 50, false, true, false, false, 2.5)\n      ],\n      walls: [\n        // Side Walls\n        new Wall(0, 550, 850, 50, 'rgb(190, 190, 190)'),\n        new Wall(0, 0, 850, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(100, 100, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(100, 200, 50, 400, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(100, 150, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        ///\n        new Wall(400, 100, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(400, 200, 50, 350, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(450, 100, 50, 450, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(150, 100, 300, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(0, 50, 50, 500, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(700, 50, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(700, 200, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(700, 350, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(700, 500, 50, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(700, 450, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(700, 300, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(700, 150, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        ///\n        new Wall(800, 50, 50, 500, 'rgb(190, 190, 190)')\n      ],\n      rocks: [\n        new Rock(300, 150, 50, 50, 'lightblue', 'aqua', '5Blue', false, 1, 1),\n        new Rock(350, 200, 50, 50, 'lightblue', 'aqua', '5Blue', false, 1, 1),\n        new Rock(450, 50, 50, 50, 'plum', 'orchid', '5Purple', false, 2, 1)\n      ],\n      finishAreas: [\n        new FinishArea(750, 50, 50, 500)\n      ],\n      changeDirectionSquares: [\n        new ChangeDirectionSquare(50, 50, 50, 50, true, false, true, false, true)\n      ],\n      unlocks: [\n        new Unlock(150, 500, 50, 50, 'rgb(180, 180, 180)', 'lightblue', 'aqua', '5Blue', 1),\n        new Unlock(350, 150, 50, 50, 'rgb(180, 180, 180)', 'plum', 'orchid', '5Purple', 2)\n      ]\n    }, /* Requirements */4, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 6\n    this.levels.push(new Level({\n      players: [\n        new Player(50, 50, 50, 50)\n      ],\n      enemies: [\n        new Enemy(700, 500, 50, 50, true, false, false, false, 2)\n      ],\n      walls: [\n        new Wall(0, 0, 850, 50, 'rgb(190, 190, 190)'),\n        new Wall(0, 550, 850, 50, 'rgb(190, 190, 190)'),\n        new Wall(800, 50, 50, 500, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(0, 50, 50, 550, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(100, 50, 50, 250, 'rgb(190, 190, 190)'),\n        new Wall(100, 350, 50, 250, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(200, 50, 50, 550, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(250, 50, 50, 250, 'rgb(190, 190, 190)'),\n        new Wall(250, 350, 50, 200, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(300, 50, 50, 250, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(350, 50, 50, 450, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(400, 50, 50, 250, 'rgb(190, 190, 190)'),\n        new Wall(450, 350, 50, 200, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(500, 150, 50, 400, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(550, 150, 200, 50, 'rgb(190, 190, 190)'),\n        new Wall(500, 100, 250, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(600, 250, 200, 250, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(750, 500, 50, 50, 'rgb(190, 190, 190)')\n      ],\n      rocks: [\n        new Rock(100, 300, 50, 50, 'plum', 'orchid', '6Purple', false, 2, 1),\n        new Rock(650, 500, 50, 50, 'plum', 'orchid', '6Purple', false, 2, 1)\n      ],\n      finishAreas: [\n        new FinishArea(150, 50, 50, 500)\n      ],\n      changeDirectionSquares: [\n        // Right Side\n        new ChangeDirectionSquare(550, 500, 50, 50, false, true, true, false, true),\n        ///\n        new ChangeDirectionSquare(550, 200, 50, 50, false, true, false, true, true),\n        ///\n        new ChangeDirectionSquare(750, 200, 50, 50, true, false, true, false, true),\n        ///\n        new ChangeDirectionSquare(750, 50, 50, 50, true, false, false, true, true),\n        // Left Side\n        new ChangeDirectionSquare(450, 50, 50, 50, false, true, false, true, true),\n        ///\n        new ChangeDirectionSquare(450, 300, 50, 50, true, false, true, false, true),\n        ///\n        new ChangeDirectionSquare(400, 300, 50, 50, false, true, false, true, true),\n        ///\n        new ChangeDirectionSquare(400, 500, 50, 50, true, false, true, false, true),\n        ///\n        new ChangeDirectionSquare(300, 500, 50, 50, false, true, true, false, true)\n      ],\n      unlocks: [\n        new Unlock(550, 500, 50, 50, 'rgb(180, 180, 180)', 'plum', 'orchid', '6Purple', 2)\n      ],\n      teleporters: [\n        new Teleporter(50, 500, 50, 50, '6Teleporter', 1),\n        new Teleporter(250, 300, 50, 50, '6Teleporter', 1)\n      ]\n    }, /* Requirements */4, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 7\n    this.levels.push(new Level({\n      players: [\n        new Player(150, 50, 50, 50)\n      ],\n      enemies: [\n        new Enemy(250, 100, 50, 50, true, false, false, false, 2.5),\n        new Enemy(50, 250, 50, 50, false, true, false, false, 3),\n        new Enemy(250, 400, 50, 50, true, false, false, false, 2.5)\n      ],\n      walls: [\n        new Wall(0, 0, 50, 600, 'rgb(190, 190, 190)'),\n        new Wall(50, 0, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(50, 550, 250, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(50, 50, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(50, 150, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(50, 300, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(50, 450, 50, 100, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(250, 50, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(250, 150, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(250, 300, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(250, 450, 50, 100, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(300, 0, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(300, 150, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(300, 300, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(300, 450, 50, 150, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(800, 50, 50, 150, 'rgb(190, 190, 190)'),\n        new Wall(800, 350, 50, 250, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(700, 50, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(650, 100, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(600, 150, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(450, 350, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(400, 400, 50, 150, 'rgb(190, 190, 190)'),\n        new Wall(350, 500, 50, 100, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(500, 500, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(550, 450, 50, 150, 'rgb(190, 190, 190)'),\n        new Wall(600, 400, 50, 200, 'rgb(190, 190, 190)'),\n        new Wall(650, 400, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(700, 500, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(750, 450, 50, 150, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(700, 100, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(650, 150, 50, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(450, 50, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(550, 0, 300, 50, 'rgb(190, 190, 190)'),\n        new Wall(450, 100, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(400, 100, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(350, 0, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(350, 150, 100, 50, 'rgb(190, 190, 190)')\n      ],\n      waters: [\n        new Water(700, 100, 100, 500, 'rgb(0, 175, 235)'),\n        new Water(650, 150, 50, 450, 'rgb(0, 175, 235)'),\n        new Water(600, 250, 50, 350, 'rgb(0, 175, 235)'),\n        ///\n        new Water(550, 300, 50, 300, 'rgb(0, 175, 235)'),\n        new Water(500, 350, 50, 250, 'rgb(0, 175, 235)'),\n        new Water(450, 450, 50, 150, 'rgb(0, 175, 235)'),\n        new Water(400, 550, 50, 50, 'rgb(0, 175, 235)')\n      ],\n      items: [\n        new Item(500, 0, 50, 50, 1)\n      ],\n      rocks: [\n        new Rock(300, 100, 50, 50, 'lightblue', 'aqua', '7Blue', false, 1, 1),\n        new Rock(300, 250, 50, 50, 'lightblue', 'aqua', '7Blue', false, 1, 1),\n        new Rock(300, 400, 50, 50, 'lightblue', 'aqua', '7Blue', false, 1, 1)\n      ],\n      finishAreas: [\n        new FinishArea(800, 200, 50, 150)\n      ],\n      unlocks: [\n        new Unlock(350, 450, 50, 50, 'rgb(180, 180, 180)', 'lightblue', 'aqua', '7Blue', 1)\n      ],\n      teleporters: [\n        new Teleporter(150, 500, '7Teleporter', 50, 50, 2),\n        new Teleporter(650, 50, '7Teleporter', 50, 50, 2)\n      ]\n    }, /* Requirements */5, 6, /* Level Borders */1, 1, 1, 1))\n\n    // Level 8\n    this.levels.push(new Level({\n      players: [\n        new Player(100, 250, 50, 50)\n      ],\n      enemies: [\n        new Enemy(500, 200, 50, 50, true, false, false, false, 2.5),\n        /// Pink Switch Puzzle\n        new Enemy(450, 300, 50, 50, false, false, false, true, 2),\n        new Enemy(550, 300, 50, 50, false, false, false, true, 2),\n        new Enemy(650, 300, 50, 50, false, false, false, true, 2),\n        /// Blue Switch Puzzle\n        new Enemy(750, 0, 50, 50, true, false, false, false, 2)\n      ],\n      walls: [\n        new Wall(0, 550, 800, 50, 'rgb(190, 190, 190)'),\n        new Wall(800, 0, 50, 600, 'rgb(190, 190, 190)'),\n        // Water Walls\n        new Wall(50, 150, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(100, 100, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(150, 50, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(200, 50, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(250, 0, 50, 100, 'rgb(190, 190, 190)'),\n        /// Middle\n        new Wall(0, 200, 350, 50, 'rgb(190, 190, 190)'),\n        new Wall(550, 150, 200, 50, 'rgb(190, 190, 190)'),\n        /// Bottom\n        new Wall(0, 300, 300, 50, 'rgb(190, 190, 190)'),\n        new Wall(400, 250, 400, 50, 'rgb(190, 190, 190)'),\n        /// Pink Switch Puzzle Entrance\n        new Wall(200, 350, 100, 100, 'rgb(190, 190, 190)'),\n        new Wall(350, 300, 100, 100, 'rgb(190, 190, 190)'),\n        new Wall(350, 400, 100, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(350, 450, 100, 100, 'rgb(190, 190, 190)'),\n        /// Life Jacket Puzzle\n        new Wall(50, 550, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(100, 500, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(0, 350, 50, 200, 'rgb(190, 190, 190)'),\n        new Wall(100, 400, 50, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(150, 400, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(50, 350, 150, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(50, 400, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        /// Pink Switch Puzzle\n        // Row 1\n        new Wall(500, 450, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(600, 450, 50, 50, 'rgb(190, 190, 190)'),\n        // Row 2\n        new Wall(500, 350, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(600, 350, 50, 50, 'rgb(190, 190, 190)'),\n        // Pathway Walls\n        new Wall(700, 350, 50, 150, 'rgb(190, 190, 190)'),\n        /// Blue Switch Puzzle\n        new Wall(350, 50, 200, 50, 'rgb(190, 190, 190)'),\n        new Wall(350, 100, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(300, 150, 200, 50, 'rgb(190, 190, 190)'),\n        new Wall(550, 50, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true),\n        new Wall(600, 50, 200, 50, 'rgb(190, 190, 190)'),\n        //\n        new Wall(300, 50, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true)\n      ],\n      waters: [\n        new Water(-50, -50, 150, 200, 'rgb(0, 175, 235)'),\n        new Water(100, -50, 50, 150, 'rgb(0, 175, 235)'),\n        new Water(150, -50, 100, 100, 'rgb(0, 175, 235)')\n      ],\n      items: [\n        new Item(50, 500, 50, 50, 1),\n        new Item(0, 150, 50, 50, 2)\n      ],\n      rocks: [\n        new Rock(550, 100, 50, 50, 'plum', 'orchid', '8Purple', false, 2, 1),\n        new Rock(50, 250, 50, 50, 'lightblue', 'aqua', '8Blue', false, 1, 1)\n      ],\n      holes: [\n        new Hole(550, 200, 50, 50, false, 0, 1),\n        /// Life Jacket Puzzle\n        new Hole(200, 450, 50, 50, false, 0, 2),\n        new Hole(150, 450, 50, 50, false, 0, 2),\n        new Hole(100, 450, 50, 50, false, 0, 1),\n        ///\n        new Hole(150, 400, 50, 50, false, 0, 1),\n        new Hole(150, 350, 50, 50, false, 0, 1),\n        new Hole(100, 350, 50, 50, false, 0, 1),\n        new Hole(50, 350, 50, 50, false, 0, 1),\n        new Hole(50, 400, 50, 50, false, 0, 1),\n        /// Pink Switch Puzzle\n        new Hole(700, 500, 50, 50, false, 0, 1),\n        new Hole(700, 300, 50, 50, false, 0, 1)\n      ],\n      finishAreas: [\n        new FinishArea(0, 250, 50, 50)\n      ],\n      changeDirectionSquares: [\n        new ChangeDirectionSquare(750, 200, 50, 50, true, false, true, false, true),\n        new ChangeDirectionSquare(750, 100, 50, 50, true, false, false, true, true),\n        new ChangeDirectionSquare(500, 100, 50, 50, false, true, false, true, true),\n        new ChangeDirectionSquare(500, 200, 50, 50, true, false, true, false, false, '8Purple')\n      ],\n      unlocks: [\n        new Unlock(750, 400, 50, 50, 'rgb(180, 180, 180)', 'plum', 'orchid', '8Purple', 2),\n        new Unlock(150, 150, 50, 50, 'rgb(180, 180, 180)', 'lightblue', 'aqua', '8Blue', 1)\n      ]\n    }, /* Requirements */7, undefined, /* Level Borders */1, 1, 1, 1))\n\n    // Level 9\n    this.levels.push(new Level({\n      players: [\n        new Player(700, 500, 50, 50)\n      ],\n      enemies: [\n        new Enemy(350, 50, 50, 50, false, false, false, true, 2, 1000),\n        new Enemy(450, 50, 50, 50, false, false, false, true, 2, 1000),\n        ///\n        new Enemy(200 + 850, 300, 50, 50, false, true, false, false, 2, 1000)\n      ],\n      walls: [\n        new Wall(0, 0, 850, 50, 'rgb(190, 190, 190)'),\n        // Bottom Water Walls\n        new Wall(400, 500, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(0, 550, 850, 50, 'rgb(190, 190, 190)'),\n        // Centre Water Walls\n        new Wall(300, 200, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(450, 200, 100, 50, 'rgb(190, 190, 190)'),\n        // Left Water Walls\n        new Wall(250, 250, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(0, 300, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(150, 300, 150, 50, 'rgb(190, 190, 190)'),\n        new Wall(0, 350, 200, 50, 'rgb(190, 190, 190)'),\n        // Right Water Walls\n        new Wall(500, 250, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(550, 300, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(750, 300, 100, 50, 'rgb(190, 190, 190)'),\n        new Wall(800, 50, 50, 250, 'rgb(190, 190, 190)'),\n        // Red Teleporter Puzzle Centre\n        new Wall(250, 50, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(250, 150, 50, 100, 'rgb(190, 190, 190)'),\n        new Wall(550, 50, 50, 50, 'rgb(190, 190, 190)'),\n        new Wall(550, 150, 50, 100, 'rgb(190, 190, 190)'),\n        // Red Teleporter Puzzle Right\n        new Wall(0, 50, 50, 250, 'rgb(190, 190, 190)'),\n        // Screen + 850\n        // Exit Puzzle Entracne\n        new Wall(0 + 850, 550, 850, 50, 'rgb(190, 190, 190)'),\n        new Wall(50 + 850, 500, 800, 50, 'rgb(190, 190, 190)'),\n        new Wall(100 + 850, 450, 750, 50, 'rgb(190, 190, 190)'),\n        new Wall(150 + 850, 400, 700, 50, 'rgb(190, 190, 190)'),\n        ///\n        new Wall(0 + 850, 0, 200, 350, 'rgb(190, 190, 190)'),\n        // Red Teleporter Puzzle\n        new Wall(200 + 850, 0, 150, 200, 'rgb(190, 190, 190)'),\n        new Wall(350 + 850, 0, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(600 + 850, 0, 250, 200, 'rgb(190, 190, 190)'),\n        // Exit Puzzle\n        new Wall(750 + 850, 250, 100, 150, 'rgb(190, 190, 190)'),\n        new Wall(650 + 850, 300, 50, 50, 'rgb(190, 190, 190)'),\n        // Red Teleporter Puzzle and Exit Puzzle Split\n        new Wall(500 + 850, 200, 350, 50, 'rgb(190, 190, 190)'),\n        new Wall(200 + 850, 200, 250, 50, 'rgb(190, 190, 190)'),\n        new Wall(450 + 850, 200, 50, 50, 'rgba(190, 190, 190, 0.9)', true, true)\n\n      ],\n      waters: [\n        new Water(350, 250, 150, 50, 'rgb(0, 175, 235)'),\n        ///\n        new Water(300, 300, 250, 50, 'rgb(0, 175, 235)'),\n        ///\n        new Water(200, 350, 450, 50, 'rgb(0, 175, 235)'),\n        ///\n        new Water(50, 400, 600, 50, 'rgb(0, 175, 235)'),\n        ///\n        new Water(50, 450, 550, 50, 'rgb(0, 175, 235)'),\n        ///\n        new Water(50, 500, 350, 50, 'rgb(0, 175, 235)')\n      ],\n      items: [\n        new Item(550 + 850, 100, 50, 50, 1)\n      ],\n      rocks: [\n        // Red Teleporter Puzzle Right Entracne\n        new Rock(650, 300, 50, 50, 'lightblue', 'aqua', '9Blue', true, 1, 1),\n        new Rock(700, 300, 50, 50, 'lightblue', 'aqua', '9Blue', true, 1, 1),\n        // Red Teleporter Puzzle Right Exit\n        new Rock(550, 100, 50, 50, 'lightblue', 'aqua', '9Blue', true, 1, 1),\n        // Red Teleporter Puzzle Centre Exit 2\n        new Rock(400, 200, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        // Exit Puzzle Entracne\n        new Rock(800, 350, 50, 50, 'lightblue', 'aqua', '9Blue', false, 1, 1),\n        new Rock(800, 400, 50, 50, 'lightblue', 'aqua', '9Blue', false, 1, 1),\n        new Rock(800, 450, 50, 50, 'lightblue', 'aqua', '9Blue', false, 1, 1),\n        new Rock(800, 500, 50, 50, 'lightblue', 'aqua', '9Blue', false, 1, 1),\n        // Water Rocks\n        new Rock(150, 400, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        new Rock(150, 450, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        new Rock(150, 500, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        // Exit Puzzle\n        new Rock(400 + 850, 250, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        new Rock(450 + 850, 250, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        new Rock(500 + 850, 250, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        ///\n        new Rock(400 + 850, 350, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        new Rock(450 + 850, 350, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1),\n        new Rock(500 + 850, 350, 50, 50, 'plum', 'orchid', '9Purple', false, 2, 1)\n      ],\n      holes: [\n        // Exit Puzzle Entracne\n        new Hole(150 + 850, 350, 50, 50, false, 1, 2)\n\n      ],\n      finishAreas: [\n        new FinishArea(0, 400, 50, 150)\n      ],\n      changeDirectionSquares: [\n      ],\n      unlocks: [\n        new Unlock(350, 500, 50, 50, 'rgb(180, 180, 180)', 'lightblue', 'aqua', '9Blue', 1),\n        new Unlock(700 + 850, 300, 50, 50, 'rgb(180, 180, 180)', 'plum', 'orchid', '9Purple', 2)\n      ],\n      teleporters: [\n        new Teleporter(100, 300, '8Teleporter', 50, 50, 1),\n        new Teleporter(350 + 850, 100, '8Teleporter', 50, 50, 1)\n      ]\n    }, /* Requirements */8, undefined, /* Level Borders */1, 1, 2, 1))\n  }\n\n  CheckLocked () {\n    return gameStates.infoController.unlockedLevel >= gameStates.currentLevelIndex\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/levels/Levels.js?");

/***/ }),

/***/ "./files/levels/Moveable.js":
/*!**********************************!*\
  !*** ./files/levels/Moveable.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChangeDirectionSquare\": () => (/* binding */ ChangeDirectionSquare),\n/* harmony export */   \"Enemy\": () => (/* binding */ Enemy),\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { draw } = __webpack_require__(/*! ../drawing/Draw */ \"./files/drawing/Draw.js\")\nconst { cubeStyle, gameStates, BackgroundStyles } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nconst { GameObject } = __webpack_require__(/*! ./Class */ \"./files/levels/Class.js\")\nclass Enemy extends GameObject {\n    constructor (x, y, width, height, movesLeft, movesRight, movesUp, movesDown, blockSpeed, waitTime) {\n      super(x, y, width, height)\n      // Moving\n      this.movesLeft = movesLeft\n      this.movesRight = movesRight\n      this.movesUp = movesUp\n      this.movesDown = movesDown\n      this.blockSpeed = blockSpeed\n      // Waiting\n      this.waitTime = waitTime\n      this.timeoutID = undefined\n      this.oldDate = undefined\n      this.pausedDate = undefined\n      // Original variables for reseting\n      this.original_x = this.x\n      this.original_y = this.y\n      this.originalMovesLeft = this.movesLeft\n      this.originalMovesRight = this.movesRight\n      this.originalMovesUp = this.movesUp\n      this.originalMovesDown = this.movesDown\n      this.original_blockSpeed = blockSpeed\n      // Other\n      this.inWater = undefined\n      this.stopHole = false\n    }\n  \n    reset () {\n      window.clearTimeout(this.timeoutID)\n      this.x = this.original_x\n      this.y = this.original_y\n      this.movesLeft = this.originalMovesLeft\n      this.movesRight = this.originalMovesRight\n      this.movesUp = this.originalMovesUp\n      this.movesDown = this.originalMovesDown\n      this.blockSpeed = this.original_blockSpeed\n      this.inWater = undefined\n    }\n  \n    setTimer () {\n      if (this.timeoutID !== null && this.timeoutID !== undefined) {\n        this.timeoutID = setTimeout(function () {\n          this.action()\n        }.bind(this), this.waitTime - (this.pausedDate - this.oldDate))\n      }\n    }\n  \n    stopTimer () {\n      window.clearTimeout(this.timeoutID)\n      this.pausedDate = new Date()\n    }\n  \n    update (delta) {\n      const oldX = this.x\n      const oldY = this.y\n      let intersectsWall = false\n      let intersectsWater = false\n      const self = this\n      if ((this.movesLeft && this.movesRight) || (this.movesUp && this.movesDown)) {\n        const chooseMovement = Math.floor(Math.random() * 2 + 1)\n        // console.log(Math2)\n        if (chooseMovement === 1) {\n          if (this.movesLeft && this.movesRight) {\n            this.movesLeft = false\n          }\n  \n          if (this.movesUp && this.movesDown) {\n            this.movesUp = false\n          }\n        }\n  \n        if (chooseMovement === 2) {\n          if (this.movesLeft && this.movesRight) {\n            this.movesRight = false\n          }\n  \n          if (this.movesUp && this.movesDown) {\n            this.movesDown = false\n          }\n        }\n      }\n      // Move Enemy\n      if (this.movesLeft) {\n        this.x = this.x - this.blockSpeed * delta\n      }\n  \n      if (this.movesRight) {\n        this.x = this.x + this.blockSpeed * delta\n      }\n  \n      if (this.movesUp) {\n        this.y = this.y - this.blockSpeed * delta\n      }\n  \n      if (this.movesDown) {\n        this.y = this.y + this.blockSpeed * delta\n      }\n  \n      // Check if touching changeDirectionSquares\n      gameStates.CurrentLevel().changeDirectionSquares.forEach(function (changeDirectionSquare) {\n        if (changeDirectionSquare.intersectsAll(self) && changeDirectionSquare.allowDirectionChange) {\n          // console.log(\"hi\")\n          if ((changeDirectionSquare.changeLeft && changeDirectionSquare.changeRight) || (changeDirectionSquare.changeUp && changeDirectionSquare.changeDown)) {\n            const chooseMovementChange = Math.floor(Math.random() * 2 + 1)\n  \n            if (chooseMovementChange === 1) {\n              if (changeDirectionSquare.changeLeft && changeDirectionSquare.changeRight) { changeDirectionSquare.changeLeft = false }\n  \n              if (changeDirectionSquare.changeUp && changeDirectionSquare.changeDown) { changeDirectionSquare.changeUp = false }\n            }\n  \n            if (chooseMovementChange === 2) {\n              if (changeDirectionSquare.changeLeft && changeDirectionSquare.changeRight) { changeDirectionSquare.changeRight = false }\n  \n              if (changeDirectionSquare.changeUp && changeDirectionSquare.changeDown) { changeDirectionSquare.changeDown = false }\n            }\n          }\n          if (self.movesLeft || self.movesRight) {\n            if (changeDirectionSquare.changeUp) {\n              self.movesUp = true\n            }\n  \n            if (changeDirectionSquare.changeDown) {\n              self.movesDown = true\n            }\n            self.movesLeft = false\n            self.movesRight = false\n          } else if (self.movesUp || self.movesDown) {\n            if (changeDirectionSquare.changeLeft) {\n              self.movesLeft = true\n            }\n  \n            if (changeDirectionSquare.changeRight) {\n              self.movesRight = true\n            }\n            self.movesUp = false\n            self.movesDown = false\n          }\n        }\n      })\n  \n      // Check if touching walls\n      gameStates.CurrentLevel().walls.forEach(function (wall) {\n        if (wall.intersects(self) && !wall.allowMovement) {\n          intersectsWall = true\n        }\n      })\n  \n      // Check if touching rocks\n      gameStates.CurrentLevel().rocks.forEach(function (rock) {\n        if (!rock.allowMovement && rock.intersects(self)) {\n          intersectsWall = true\n        }\n      })\n  \n      // Check if touching holes\n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (!hole.fullHole && hole.intersectsAll(self)) {\n          hole.currentIntersects = hole.currentIntersects + 1\n          self.stopHole = true\n          hole.stopEnemy = true\n        }\n  \n        if (hole.stopEnemy && self.stopHole && !hole.intersects(self)) {\n          self.stopHole = false\n          hole.stopEnemy = false\n        }\n  \n        if (hole.fullHole && hole.intersects(self) && self.stopHole === false && hole.stopEnemy === false) {\n          intersectsWall = true\n        }\n      })\n  \n      // Check if touching waters\n      gameStates.CurrentLevel().waters.forEach(function (water) {\n        if (water.intersects(self)) {\n          intersectsWater = true\n        }\n      })\n      // Chnage speed if in water\n      if (intersectsWater && (this.inWater === false || this.inWater === undefined)) {\n        this.blockSpeed = this.blockSpeed / 2\n      }\n  \n      if (!intersectsWater && this.inWater === true) {\n        this.blockSpeed = this.blockSpeed * 2\n      }\n      this.inWater = intersectsWater\n  \n      // Check if touching finishAreas\n      gameStates.CurrentLevel().finishAreas.forEach(function (finishArea) {\n        if (finishArea.intersects(self)) {\n          intersectsWall = true\n        }\n      })\n  \n      if ((this.movesLeft && this.x <= (0 + 850 * (gameStates.CurrentLevel().width - 1))) || (this.movesLeft && intersectsWall)) {\n        this.movesLeft = false\n        this.x = oldX\n        if (this.waitTime !== undefined && this.waitTime !== null) {\n          this.oldDate = new Date()\n          this.action = function () {\n            self.movesRight = true\n            self.timeoutId = undefined\n            // self.action = undefined\n          }\n          this.timeoutID = setTimeout(function () {\n            self.action()\n          }, self.waitTime)\n        } else {\n          this.movesRight = true\n        }\n        return\n      }\n  \n      if ((this.movesRight && this.x >= (850 * gameStates.CurrentLevel().width - this.width)) || (this.movesRight && intersectsWall)) {\n        this.movesRight = false\n        this.x = oldX\n        if (this.waitTime !== undefined) {\n          this.oldDate = new Date()\n          this.action = function () {\n            self.movesLeft = true\n            self.timeoutId = undefined\n            // self.action = undefined\n          }\n          this.timeoutID = setTimeout(function () {\n            self.action()\n          }, self.waitTime)\n        } else {\n          this.movesLeft = true\n        }\n        return\n      }\n  \n      if ((this.movesUp && this.y <= (600 * (gameStates.CurrentLevel().height - 1))) || (this.movesUp && intersectsWall)) {\n        this.movesUp = false\n        this.y = oldY\n        if (this.waitTime !== undefined) {\n          this.oldDate = new Date()\n          this.action = function () {\n            self.movesDown = true\n            self.timeoutId = undefined\n            // self.action = undefined\n          }\n          this.timeoutID = setTimeout(function () {\n            self.action()\n          }, self.waitTime)\n        } else {\n          this.movesDown = true\n        }\n        return\n      }\n  \n      if ((this.movesDown && this.y >= (600 * gameStates.CurrentLevel().height - this.height)) || (this.movesDown && intersectsWall)) {\n        this.movesDown = false\n        this.y = oldY\n        if (this.waitTime !== undefined) {\n          this.oldDate = new Date()\n          this.action = function () {\n            self.movesUp = true\n            self.timeoutId = undefined\n            // self.action = undefined\n          }\n          this.timeoutId = setTimeout(function () {\n            self.action()\n          }, self.waitTime)\n        } else {\n          this.movesUp = true\n        }\n      }\n    }\n  \n    Draw () {\n      if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n        draw.DrawImage(images.RedCube, this.x, this.y)\n      } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n        draw.DrawImage(images.RedCubePlastic, this.x, this.y)\n      }\n    }\n};\n  \nclass Player extends GameObject {\n    constructor (x, y, width, height) {\n      super(x, y, width, height)\n      // Original variables for reseting\n      this.original_x = this.x\n      this.original_y = this.y\n      // Other\n      this.previousIntersectsHole = false\n    }\n  \n    moveRight () {\n      const oldX = this.x\n      this.x = this.x + 50\n      let intersectsWall = false\n      const self = this\n      gameStates.CurrentLevel().walls.forEach(function (wall) {\n        if (!wall.allowMovement && wall.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().rocks.forEach(function (rock) {\n        if (!rock.allowMovement && rock.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().waters.forEach(function (water) {\n        gameStates.CurrentLevel().items.forEach(function (item) {\n          if (!item.allowMovementWater && item.typeNumber === 1 && water.intersects(self)) {\n            intersectsWall = true\n            gameStates.CurrentLevel().holes.forEach(function (hole) {\n              hole.stopPlayer = true\n            })\n          }\n        })\n      })\n  \n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.intersects(self) && !hole.fullHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = true\n        }\n        if (!hole.intersects(self) && hole.previousIntersectsHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = false\n        }\n      })\n  \n      gameStates.CurrentLevel().items.forEach(function (item) {\n        if (item.intersects(self)) {\n          if (item.typeNumber === 1) {\n            item.allowMovementWater = true\n          }\n          item.collected = true\n        }\n      })\n  \n      if (intersectsWall) {\n        this.x = oldX\n      }\n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.stopPlayer) { hole.stopPlayer = false }\n      })\n    }\n  \n    moveLeft () {\n      const oldX = this.x\n      this.x = this.x - 50\n      let intersectsWall = false\n      const self = this\n      gameStates.CurrentLevel().walls.forEach(function (wall) {\n        if (!wall.allowMovement && wall.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().rocks.forEach(function (rock) {\n        if (!rock.allowMovement && rock.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().waters.forEach(function (water) {\n        gameStates.CurrentLevel().items.forEach(function (item) {\n          if (!item.allowMovementWater && item.typeNumber === 1 && water.intersects(self)) {\n            intersectsWall = true\n            gameStates.CurrentLevel().holes.forEach(function (hole) {\n              hole.stopPlayer = true\n            })\n          }\n        })\n      })\n  \n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.intersects(self) && !hole.fullHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = true\n        }\n        if (!hole.intersects(self) && hole.previousIntersectsHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = false\n        }\n      })\n  \n      gameStates.CurrentLevel().items.forEach(function (item) {\n        if (item.intersects(self)) {\n          if (item.typeNumber === 1) {\n            item.allowMovementWater = true\n          }\n          item.collected = true\n        }\n      })\n  \n      if (intersectsWall) {\n        this.x = oldX\n      }\n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.stopPlayer) { hole.stopPlayer = false }\n      })\n    }\n  \n    moveDown () {\n      const oldY = this.y\n      this.y = this.y + 50\n      let intersectsWall = false\n      const self = this\n      gameStates.CurrentLevel().walls.forEach(function (wall) {\n        if (!wall.allowMovement && wall.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().rocks.forEach(function (rock) {\n        if (!rock.allowMovement && rock.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().waters.forEach(function (water) {\n        gameStates.CurrentLevel().items.forEach(function (item) {\n          if (!item.allowMovementWater && item.typeNumber === 1 && water.intersects(self)) {\n            intersectsWall = true\n            gameStates.CurrentLevel().holes.forEach(function (hole) {\n              hole.stopPlayer = true\n            })\n          }\n        })\n      })\n  \n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.intersects(self) && !hole.fullHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = true\n        }\n        if (!hole.intersects(self) && hole.previousIntersectsHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = false\n        }\n      })\n  \n      gameStates.CurrentLevel().items.forEach(function (item) {\n        if (item.intersects(self)) {\n          if (item.typeNumber === 1) {\n            item.allowMovementWater = true\n          }\n          item.collected = true\n        }\n      })\n  \n      if (intersectsWall) {\n        this.y = oldY\n      }\n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.stopPlayer) { hole.stopPlayer = false }\n      })\n    }\n  \n    moveUp () {\n      const oldY = this.y\n      this.y = this.y - 50\n      let intersectsWall = false\n      const self = this\n      gameStates.CurrentLevel().walls.forEach(function (wall) {\n        if (!wall.allowMovement && wall.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().rocks.forEach(function (rock) {\n        if (!rock.allowMovement && rock.intersects(self)) {\n          intersectsWall = true\n          gameStates.CurrentLevel().holes.forEach(function (hole) {\n            hole.stopPlayer = true\n          })\n        }\n      })\n  \n      gameStates.CurrentLevel().waters.forEach(function (water) {\n        gameStates.CurrentLevel().items.forEach(function (item) {\n          if (!item.allowMovementWater && item.typeNumber === 1 && water.intersects(self)) {\n            intersectsWall = true\n            gameStates.CurrentLevel().holes.forEach(function (hole) {\n              hole.stopPlayer = true\n            })\n          }\n        })\n      })\n  \n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.intersects(self) && !hole.fullHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = true\n        }\n        if (!hole.intersects(self) && hole.previousIntersectsHole && !hole.stopPlayer) {\n          hole.currentIntersects = hole.currentIntersects + 0.5\n          hole.previousIntersectsHole = false\n        }\n      })\n  \n      gameStates.CurrentLevel().items.forEach(function (item) {\n        if (item.intersects(self)) {\n          if (item.typeNumber === 1) {\n            item.allowMovementWater = true\n          }\n          item.collected = true\n        }\n      })\n  \n      if (intersectsWall) {\n        this.y = oldY\n      }\n      gameStates.CurrentLevel().holes.forEach(function (hole) {\n        if (hole.stopPlayer) { hole.stopPlayer = false }\n      })\n    }\n  \n    Keydown(event, keybindArray) {\n      // \"Right\" Arrow || \"d\" Key\n      if (keybindArray[1/* right */].keybindA === event.key || keybindArray[1/* right */].keybindB === event.key) {\n          this.moveRight()\n          return\n        }\n  \n        // \"Down\" Arrow || \"s\" Key\n        if (keybindArray[3/* down */].keybindA === event.key || keybindArray[3/* down */].keybindB === event.key) {\n          this.moveDown()\n          return\n        }\n  \n        // \"Up\" Arrow || \"w\" Key\n        if (keybindArray[2/* up */].keybindA === event.key || keybindArray[2/* up */].keybindB === event.key) {\n          this.moveUp()\n          return\n        }\n  \n        // \"Left\" Arrow || \"a\" Key\n        if (keybindArray[0/* left */].keybindA === event.key || keybindArray[0/* left */].keybindB === event.key) {\n          this.moveLeft()\n          return\n        }\n    }\n  \n    reset () {\n      this.x = this.original_x\n      this.y = this.original_y\n    }\n  \n    update () {\n    }\n  \n    Draw () {\n      if (gameStates.currentCubeStyle === cubeStyle.Classic) { this.drawX = 0 } else if (gameStates.currentCubeStyle === cubeStyle.Alien) { this.drawX = 50 } else if (gameStates.currentCubeStyle === cubeStyle.Sad) { this.drawX = 100 } else if (gameStates.currentCubeStyle === cubeStyle.Happy) { this.drawX = 150 }\n  \n      if (gameStates.currentBackgroundStyle === BackgroundStyles.Classic) {\n        canvas.context.drawImage(images.BlueCube, this.drawX, 0, 50, images.BlueCube.height, this.x, this.y, 50, images.BlueCube.height)\n      } else if (gameStates.currentBackgroundStyle === BackgroundStyles.Plastic) {\n        canvas.context.drawImage(images.BlueCubePlastic, this.drawX, 0, 50, images.BlueCubePlastic.height, this.x, this.y, 50, images.BlueCubePlastic.height)\n      }\n    }\n};\ngameStates.currentCubeStyle = cubeStyle.BlueCube\n\nclass ChangeDirectionSquare extends GameObject {\n    constructor (x, y, width, height, changeLeft, changeRight, changeUp, changeDown, allowDirectionChange, title) {\n      super(x, y, width, height, 'red')\n      this.original_x = this.x\n      this.original_y = this.y\n      this.color2 = 'orange'\n      this.allowDirectionChangeOld = allowDirectionChange\n      this.allowDirectionChange = allowDirectionChange\n      this.changeLeft = changeLeft\n      this.changeRight = changeRight\n      this.changeUp = changeUp\n      this.changeDown = changeDown\n      this.title = title\n    }\n  \n    Draw () {\n      if (!this.allowDirectionChange) { canvas.context.fillStyle = this.color2 } else { canvas.context.fillStyle = this.color1 }\n      canvas.context.fillRect(this.x, this.y, this.width, this.height)\n    }\n  \n    reset () {\n      this.x = this.original_x\n      this.y = this.original_y\n      this.allowDirectionChange = this.allowDirectionChangeOld\n    }\n};\n\n//# sourceURL=webpack://cube-adventure/./files/levels/Moveable.js?");

/***/ }),

/***/ "./files/menuModes/ArrayChart.js":
/*!***************************************!*\
  !*** ./files/menuModes/ArrayChart.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayChartController\": () => (/* binding */ ArrayChartController)\n/* harmony export */ });\n\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { gameMode, ShopMode, gameStates, settingStates, cubeStyle, BackgroundStyles, drawUpdate } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nclass ArrayChartController {\n  constructor () {\n    this.arrayCharts = []\n    this.arrayCharts.push(this.colours = new ArrayChart(/* title */'Theme Colour', /* currentSelection */10, /* offsetX */0, /* offsetY */300, /* sectionWidth */135.75, /* sectionHeight */135.75, /* loopWidth */6, /* loopHeight */2, [\n      new ArrayChartBox(/* displayName */'Red', /* locked */false, /* value */'rgb(255, 179, 179)', /* colour */'rgb(255, 179, 179)', /* boarder */'rgb(0, 0, 0)'),\n      new ArrayChartBox('Orange', false, 'rgb(255, 211, 179)', 'rgb(255, 211, 179)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Yellow', false, 'rgb(255, 243, 179)', 'rgb(255, 243, 179)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Lime', false, 'rgb(179, 255, 179)', 'rgb(179, 255, 179)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Aqua', false, 'rgb(178, 255, 210)', 'rgb(178, 255, 210)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Light Blue', false, 'rgb(179, 249, 255)', 'rgb(179, 249, 255)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Blue', false, 'rgb(179, 186, 255)', 'rgb(179, 186, 255)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Purple', false, 'rgb(211, 179, 255)', 'rgb(211, 179, 255)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Magenta', false, 'rgb(255, 179, 255)', 'rgb(255, 179, 255)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Pink', false, 'rgb(255, 179, 217)', 'rgb(255, 179, 217)', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Light Gray', false, 'lightgray', 'lightgray', 'rgb(0, 0, 0)'),\n      new ArrayChartBox('Dark Gray', false, 'rgb(137, 137, 137)', 'rgb(137, 137, 137)', 'rgb(0, 0, 0)')\n    ], function (arrayChart, currentSelectionCheck) {\n      if (!arrayChart.items[currentSelectionCheck].locked) {\n        arrayChart.currentSelection = currentSelectionCheck\n        gameStates.currentThemeColour = arrayChart.items[arrayChart.currentSelection].value\n      }\n    }))\n\n    this.arrayCharts.push(this.backroundStyles = new ArrayChart(/* title */'Background Style', /* currentSelection */0, /* offsetX */220, /* offsetY */300, /* sectionWidth */200, /* sectionHeight */200, /* loopWidth */2, /* loopHeight */1, [\n      new ArrayChartImage(/* displayName */'Classic', /* locked */false, /* value */BackgroundStyles.Classic, /* image */images.WallGrassClassicA_400x400, /* imageStartX */-4, /* imageStartY */0, /* imageStartWidth */images.WallGrassClassicA_400x400.width, /* imageStartHeight */images.WallGrassClassicA_400x400.height),\n      new ArrayChartBox(/* displayName */'Plastic', drawUpdate.highestLevelLock, /* value */BackgroundStyles.Plastic, /* colour */'rgb(127, 127, 127)', /* boarder */'rgb(0, 0, 0)', /* checkLocked */function () { this.locked = drawUpdate.highestLevelLock })\n    ], function (arrayChart, currentSelectionCheck) {\n      if (!arrayChart.items[currentSelectionCheck].locked) {\n        arrayChart.currentSelection = currentSelectionCheck\n        gameStates.currentBackgroundStyle = arrayChart.items[arrayChart.currentSelection].value\n      }\n    }))\n\n    this.arrayCharts.push(this.playerStyles = new ArrayChart(/* title */'Player Style', /* currentSelection */0, /* offsetX */12.5, /* offsetY */300, /* sectionWidth */200, /* sectionHeight */200, /* loopWidth */4, /* loopHeight */1, [\n      new ArrayChartImage(/* displayName */'Classic', /* locked */false, /* value */cubeStyle.Classic, /* image */images.BlueCube_400x400, /* imageStartX */0, /* imageStartY */0, /* imageStartWidth */200, /* imageStartHeight */images.BlueCube_400x400.height),\n      new ArrayChartImage('Alien', drawUpdate.blueCubeAlienLock, cubeStyle.Alien, images.BlueCube_400x400, 200, 0, 200, images.BlueCube_400x400.height, /* checkLocked */function () { this.locked = drawUpdate.blueCubeAlienLock }),\n      new ArrayChartImage('Sad', drawUpdate.blueCubeSadLock, cubeStyle.Sad, images.BlueCube_400x400, 400, 0, 200, images.BlueCube_400x400.height, function () { this.locked = drawUpdate.blueCubeSadLock }),\n      new ArrayChartImage('Happy', drawUpdate.highestLevelLock, cubeStyle.Happy, images.BlueCube_400x400, 600, 0, 200, images.BlueCube_400x400.height, function () { this.locked = drawUpdate.highestLevelLock })\n    ], function (arrayChart, currentSelectionCheck) {\n      if (!arrayChart.items[currentSelectionCheck].locked) {\n        arrayChart.currentSelection = currentSelectionCheck\n        gameStates.currentCubeStyle = arrayChart.items[arrayChart.currentSelection].value\n      }\n    }))\n  }\n\n  findCurrentArrayChart () {\n    if (gameStates.currentSettingState === settingStates.ThemeColourSelection && gameStates.currentGameMode === gameMode.Settings) { return 0 }\n    if (gameStates.currentGameMode === gameMode.Shop) {\n      if (gameStates.currentShopMode === ShopMode.Backround) { return 1 }\n      if (gameStates.currentShopMode === ShopMode.Player) { return 2 }\n    }\n    return false\n  }\n};\n\nclass ArrayChart {\n  constructor (title, currentSelection, offsetX, offsetY, sectionWidth, sectionHeight, loopWidth, loopHeight, items, action) {\n    this.title = title\n    this.currentSelection = currentSelection\n    this.offsetX = offsetX\n    this.offsetY = offsetY\n    this.sectionWidth = sectionWidth\n    this.sectionHeight = sectionHeight\n    this.loopWidth = loopWidth\n    this.loopHeight = loopHeight\n    this.items = items\n    this.action = action\n    this.currentX = 0\n    this.currentY = 0\n  }\n\n  Draw () {\n    canvas.context.font = '95px Arial'\n    canvas.context.fillStyle = 'darkGray'\n    canvas.context.fillText(this.title, 10, 80)\n    canvas.context.fillStyle = 'black'\n    canvas.context.fillText(this.items[this.currentSelection].displayName, 10, 200)\n  }\n\n  update () {\n    let numberDrew = 0\n    for (let col = 0; col < this.loopHeight; col++) {\n      for (let row = 0; row < this.loopWidth; row++) {\n        this.items[numberDrew].currentArrayChart = gameStates.arrayChartController.arrayCharts[gameStates.arrayChartController.findCurrentArrayChart()]\n        this.items[numberDrew].x = 5 * (row + 1) + this.offsetX + row * this.sectionWidth\n        this.items[numberDrew].y = 5 * (col + 1) + this.offsetY + col * this.sectionHeight\n        if (numberDrew === this.currentSelection) { this.items[numberDrew].currentSelected = true } else { this.items[numberDrew].currentSelected = false }\n        numberDrew++\n      }\n    }\n  }\n\n  Keydown(event, keybindArray) {\n      // \"Left\" \n      if ((keybindArray[0/* left */].keybindA === event.key || keybindArray[0/* left */].keybindB === event.key) && this.currentX !== 0) { this.currentX-- }\n\n      // \"Right\" \n      if ((keybindArray[1/* right */].keybindA === event.key || keybindArray[1/* right */].keybindB === event.key) && this.currentX !== this.loopWidth - 1) { this.currentX++ }\n\n      // \"Up\" \n      if ((keybindArray[2/* up */].keybindA === event.key || keybindArray[2/* up */].keybindB === event.key) && this.currentY !== 0) { this.currentY-- }\n\n      // \"Down\"\n      if ((keybindArray[3/* down */].keybindA === event.key || keybindArray[3/* down */].keybindB === event.key) && this.currentY !== this.loopHeight - 1) { this.currentY++ }\n\n      // \"Select\" \n      if ((keybindArray[4/* select */].keybindA === event.key || keybindArray[4/* select */].keybindB === event.key)) { this.action(this, this.currentY * this.loopWidth + this.currentX) }\n  }\n};\n\nclass ArrayChartBox {\n  constructor (displayName, locked, value, colour, boarder, checkedLocked) {\n    this.displayName = displayName\n    this.locked = locked\n    this.value = value\n    this.colour = colour\n    this.boarder = boarder\n    this.checkedLocked = checkedLocked\n    this.currentSelected = false\n  }\n\n  Draw (row, col) {\n    if (!this.locked) {\n      if (this.currentArrayChart.currentX === row && this.currentArrayChart.currentY === col) { canvas.context.fillStyle = 'white' } else { canvas.context.fillStyle = this.boarder }\n      canvas.context.fillRect(this.x, this.y, this.currentArrayChart.sectionWidth, this.currentArrayChart.sectionHeight)\n      // darwBoxStart\n      canvas.context.fillStyle = this.colour\n      canvas.context.fillRect(this.x + 5, this.y + 5, this.currentArrayChart.sectionWidth - 10, this.currentArrayChart.sectionHeight - 10)\n    } else {\n      if (this.currentArrayChart.currentX === row && this.currentArrayChart.currentY === col) {\n        canvas.context.fillStyle = 'white'\n        canvas.context.fillRect(this.x, this.y, this.currentArrayChart.sectionWidth, this.currentArrayChart.sectionHeight)\n      }\n      canvas.context.drawImage(images.LockedIcon, 0, 0, images.LockedIcon.width, images.LockedIcon.height, this.x + 5, this.y + 5, this.currentArrayChart.sectionWidth - 10, this.currentArrayChart.sectionHeight - 10)\n    }\n  }\n\n  Update () {\n    if (this.checkedLocked !== undefined && this.checkedLocked !== null) { this.checkedLocked() }\n  }\n};\n\nclass ArrayChartImage {\n  constructor (displayName, locked, value, image, imageStartX, imageStartY, imageStartWidth, imageStartHeight, checkedLocked) {\n    this.displayName = displayName\n    this.locked = locked\n    this.value = value\n    this.image = image\n    this.imageStartX = imageStartX\n    this.imageStartY = imageStartY\n    this.imageStartWidth = imageStartWidth\n    this.imageStartHeight = imageStartHeight\n    this.checkedLocked = checkedLocked\n    this.currentSelected = false\n  }\n\n  Draw (row, col) {\n    if (this.currentArrayChart.currentX === row && this.currentArrayChart.currentY === col) {\n      canvas.context.fillStyle = 'white'\n      canvas.context.fillRect(this.x, this.y, this.currentArrayChart.sectionWidth, this.currentArrayChart.sectionHeight)\n    }\n    if (!this.locked) { canvas.context.drawImage(this.image, this.imageStartX, this.imageStartY, this.imageStartWidth, this.imageStartHeight, this.x + 5, this.y + 5, this.currentArrayChart.sectionWidth - 10, this.currentArrayChart.sectionHeight - 10) } else { canvas.context.drawImage(images.LockedIcon, 0, 0, images.LockedIcon.width, images.LockedIcon.height, this.x + 5, this.y + 5, this.currentArrayChart.sectionWidth - 10, this.currentArrayChart.sectionHeight - 10) }\n  }\n\n  Update () {\n    if (this.checkedLocked !== undefined && this.checkedLocked !== null) { this.checkedLocked() }\n  }\n};\n\n\n//# sourceURL=webpack://cube-adventure/./files/menuModes/ArrayChart.js?");

/***/ }),

/***/ "./files/menuModes/ItemInfo.js":
/*!*************************************!*\
  !*** ./files/menuModes/ItemInfo.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InfoController\": () => (/* binding */ InfoController)\n/* harmony export */ });\n\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { draw } = __webpack_require__(/*! ../drawing/Draw */ \"./files/drawing/Draw.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nconst { gameStates } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\n\nconst LockedFeature = {\n  infoCuber: 1,\n  infoCuber2: 9,\n  infoCuber3: 10,\n  infoRollphant1: 11,\n  ///\n  infoWall: 2,\n  infoInvisibleWall: 5,\n  infoWater: 7,\n  ///\n  infoSwitch: 4,\n  infoTeleporter: 6,\n  ///\n  infoRock: 4,\n  ///\n  infoLifeJacket: 7,\n  infoFinishItems: 10,\n  infoFireShard: 10,\n  ///\n  infoHole: 8\n}\n\nclass InfoController {\n  constructor () {\n    this.items = [\n      new EnemyInfo(),\n      new BarrierInfo(),\n      new IntractableInfo(),\n      new UnlockableInfo(),\n      new CollectableInfo(),\n      new TrapInfo()\n    ]\n    this.itemIndex = 0\n    this.slideIndex = 0\n    this.unlockedLevel = 0\n  }\n\n  Keydown (event, keybindArray) {\n    // Down\n    if ((keybindArray[3/* down */].keybindA === event.key || keybindArray[3/* down */].keybindB === event.key) && this.itemIndex < (this.items.length - 1)) {\n      this.itemIndex = this.itemIndex + 1\n      this.slideIndex = 0\n    }\n\n    // Up\n    if ((keybindArray[2/* up */].keybindA === event.key || keybindArray[2/* up */].keybindB === event.key) && this.itemIndex !== 0) {\n      this.itemIndex = this.itemIndex - 1\n      this.slideIndex = 0\n    }\n\n    // Right\n    if ((keybindArray[1/* right */].keybindA === event.key || keybindArray[1/* right */].keybindB === event.key) && this.slideIndex < this.items[this.itemIndex].slides.length - 1) { this.slideIndex = this.slideIndex + 1 }\n\n    // Left\n    if ((keybindArray[0/* left */].keybindA === event.key || keybindArray[0/* left */].keybindB === event.key) && this.slideIndex > 0) { this.slideIndex = this.slideIndex - 1 }\n  }\n\n  Mousedown (event) {\n    // Forward\n    if (event.offsetY > 150 && event.offsetY < 450) {\n      if ((this.items[this.itemIndex].slides.length - 1) === this.slideIndex) { this.slideIndex = 0 } else { this.slideIndex++ }\n      return\n    }\n\n    // Down\n    if (event.offsetY > 450 && event.offsetY < 600 && event.offsetX < 850 && this.itemIndex < (this.items.length - 1)) {\n      this.itemIndex = this.itemIndex + 1\n      this.slideIndex = 0\n    }\n\n    // Up\n    if (event.offsetY > 0 && event.offsetY < 150 && event.offsetX < 850 && this.itemIndex !== 0) {\n      this.itemIndex = this.itemIndex - 1\n      this.slideIndex = 0\n    }\n  }\n\n  Draw () {\n    this.items[this.itemIndex].slides[this.slideIndex].Draw()\n  }\n};\n\nclass ItemText {\n  constructor (text, textSize, textColour, textX, textY) {\n    this.text = text\n    this.textSize = textSize\n    this.textColour = textColour\n    this.textX = textX\n    this.textY = textY\n  }\n\n  Draw () {\n    canvas.context.font = this.textSize\n    canvas.context.fillStyle = this.textColour\n    canvas.context.fillText(this.text, this.textX, this.textY)\n  }\n};\n\nclass ItemImage {\n  constructor (fullImage, image, placementX, placementY, placementWidth, placementHeight, imageX, imageY, imageWidth, imageHeight) {\n    this.image = image\n    this.imageX = imageX\n    this.imageY = imageY\n    this.imageWidth = imageWidth\n    this.imageHeight = imageHeight\n    ///\n    this.placementX = placementX\n    this.placementY = placementY\n    this.placementWidth = placementWidth\n    this.placementHeight = placementHeight\n    ///\n    this.fullImage = fullImage\n  }\n\n  Draw () {\n    if (this.fullImage) {\n      canvas.context.drawImage(this.image, this.imageX, this.imageY, this.imageWidth, this.imageHeight, this.placementX, this.placementY, this.placementWidth, this.placementHeight)\n    } else if (!this.fullImage) {\n      draw.DrawImage(this.image, this.placementX, this.placementY)\n    }\n  }\n};\n\nclass ItemSlide {\n  constructor (items, neededFeature) {\n    this.items = items\n    this.neededFeature = neededFeature\n  }\n\n  ShouldShowSlide (unlockedLevel) {\n    return unlockedLevel >= this.neededFeature\n  }\n\n  Draw () {\n    canvas.context.font = '25px Arial'\n    canvas.context.fillStyle = 'black'\n    canvas.context.fillText(gameStates.infoController.slideIndex + ' / ' + (gameStates.infoController.items[gameStates.infoController.itemIndex].slides.length - 1), 790, 590)\n    ///\n    if (this.ShouldShowSlide(gameStates.infoController.unlockedLevel)) {\n      this.items.forEach(function (itemInfo) {\n        itemInfo.Draw()\n      })\n    } else {\n      canvas.context.font = '125px Arial'\n      canvas.context.fillStyle = 'lightcoral'\n      canvas.context.fillText('Item ' + gameStates.infoController.slideIndex, 200, 200)\n      ///\n      canvas.context.fillStyle = 'lime'\n      if (this.neededFeature >= 10) {\n        canvas.context.font = '125px Arial'\n        canvas.context.fillText('Beat Level ' + this.neededFeature, 35, 550)\n      } else {\n        canvas.context.font = '150px Arial'\n        canvas.context.fillText('Beat Level ' + this.neededFeature, 10, 550)\n      }\n    }\n  }\n};\n\nclass EnemyInfo {\n  constructor () {\n    const titleSlide = new ItemSlide([\n      new ItemText('Enemies', '200px Arial', 'purple', 10, 400)\n    ], 0)\n\n    const slide1 = new ItemSlide([\n      new ItemImage(false, images.RedCube_200x200, 562.5, 10),\n      ///\n      new ItemText('Cubers', '150px Arial', 'purple', 10, 150),\n      new ItemText('Cubers move left to right or up to', '50px Arial', 'rgb(2, 0, 139)', 10, 275),\n      new ItemText('down at a time.', '50px Arial', 'rgb(2, 0, 139)', 10, 350),\n      new ItemText('Players lose when they touch a cuber.', '48px Arial', 'rgb(2, 0, 139)', 10, 450),\n      new ItemText('Cubers can move at different speeds.', '48px Arial', 'rgb(2, 0, 139)', 10, 550)\n    ], LockedFeature.infoCuber)\n\n    const slide2 = new ItemSlide([\n      new ItemImage(false, images.RedCube_200x200, 562.5, 10),\n      ///\n      new ItemText('Cubers', '150px Arial', 'purple', 10, 150),\n      new ItemText('Cubers may wait when they touch', '50px Arial', 'rgb(2, 0, 139)', 10, 262.5),\n      new ItemText('walls or change direction.', '50px Arial', 'rgb(2, 0, 139)', 15, 337.5),\n      new ItemText('Cuber may only wait when moving', '50px Arial', 'rgb(2, 0, 139)', 10, 425),\n      new ItemText('certain directions.', '50px Arial', 'rgb(2, 0, 139)', 10, 500),\n      new ItemText('Cubers can wait different times.', '50px Arial', 'rgb(2, 0, 139)', 10, 587.5)\n    ], LockedFeature.infoCuber2)\n\n    const slide3 = new ItemSlide([\n      new ItemImage(false, images.RedCube_200x200, 562.5, 10),\n      ///\n      new ItemText('Cubers', '150px Arial', 'purple', 10, 150),\n      new ItemText('Cubers can activate switches.', '60px Arial', 'rgb(2, 0, 139)', 10, 275),\n      new ItemText('Cubers can be defeated.', '60px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText('Cubers may drop items when', '60px Arial', 'rgb(2, 0, 139)', 10, 475),\n      new ItemText('defeated.', '60px Arial', 'rgb(2, 0, 139)', 10, 550)\n    ], LockedFeature.infoCuber3)\n\n    const slide4 = new ItemSlide([\n      new ItemImage(false, images.RedCube_200x200/* images.Rollphant_200x200 */, 600, 10),\n      ///\n      new ItemText('Rollphant', '125px Arial', 'purple', 10, 150)\n    ], LockedFeature.infoRollphant1)\n\n    this.slides = [titleSlide, slide1, slide2, slide3, slide4]\n  }\n};\n\nclass BarrierInfo {\n  constructor () {\n    const titleSlide = new ItemSlide([\n      new ItemText('Barriers', '200px Arial', 'purple', 10, 400)\n    ], 0)\n\n    const cuberSlide1 = new ItemSlide([\n      new ItemImage(false, images.WallGrassClassicA_200x200, 550, 10),\n      ///\n      new ItemText('Walls', '200px Arial', 'purple', 10, 160),\n      new ItemText('Walls stop players movement.', '60px Arial', 'rgb(2, 0, 139)', 10, 300),\n      new ItemText('Cubers turn the opposite way,', '60px Arial', 'rgb(2, 0, 139)', 10, 400),\n      new ItemText('when they touch walls.', '60px Arial', 'rgb(2, 0, 139)', 15, 475),\n      new ItemText('Walls can look different.', '60px Arial', 'rgb(2, 0, 139)', 10, 575)\n    ], LockedFeature.infoWall)\n\n    const fakeWallSlide1 = new ItemSlide([\n      new ItemImage(false, images.InvisibleWall_200x200, 625, 10),\n      ///\n      new ItemText('Fake Walls', '120px Arial', 'purple', 10, 150),\n      new ItemText('Fake walls look like walls but', '60px Arial', 'rgb(2, 0, 139)', 10, 300),\n      new ItemText('their different.', '60px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText(\"Fake walls don't do anthing.\", '60px Arial', 'rgb(2, 0, 139)', 10, 475),\n      new ItemText('Fake walls can look different.', '60px Arial', 'rgb(2, 0, 139)', 10, 575)\n    ], LockedFeature.infoInvisibleWall)\n\n    const waterSlide1 = new ItemSlide([\n      new ItemImage(false, images.Water_Medium_200x200, 600, 10),\n      ///\n      new ItemText('Water', '200px Arial', 'purple', 10, 175),\n      new ItemText('Players need life jackets to go in', '55px Arial', 'rgb(2, 0, 139)', 10, 300),\n      new ItemText('water.', '55px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText('Cubers can go into water but,', '55px Arial', 'rgb(2, 0, 139)', 10, 475),\n      new ItemText('they move at half the speed.', '55px Arial', 'rgb(2, 0, 139)', 10, 550)\n    ], LockedFeature.infoWater)\n\n    this.slides = [titleSlide, cuberSlide1, fakeWallSlide1, waterSlide1]\n  }\n};\n\nclass IntractableInfo {\n  constructor () {\n    const titleSlide = new ItemSlide([\n      new ItemText('Intractables', '150px Arial', 'purple', 10, 400)\n    ], 0)\n\n    const switchSlide1 = new ItemSlide([\n      new ItemImage(false, images.SwitchW1Blue_200x200, 550, 10),\n      ///\n      new ItemText('Reverse', '125px Arial', 'purple', 10, 100),\n      new ItemText('Tiles', '125px Arial', 'purple', 75, 220),\n      new ItemText('Players can only go on reverse tiles.', '50px Arial', 'rgb(2, 0, 139)', 10, 275),\n      new ItemText('When players go on a reverse tile, it ', '50px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText('activates.', '50px Arial', 'rgb(2, 0, 139)', 10, 425),\n      new ItemText('Different reverse tiles can have', '50px Arial', 'rgb(2, 0, 139)', 10, 525),\n      new ItemText('different colours.', '50px Arial', 'rgb(2, 0, 139)', 10, 575)\n    ], LockedFeature.infoSwitch)\n\n    const switchSlide2 = new ItemSlide([\n      new ItemImage(false, images.SwitchW1Purple_200x200, 550, 10),\n      ///\n      new ItemText('Reverse', '125px Arial', 'purple', 10, 100),\n      new ItemText('Tiles', '125px Arial', 'purple', 75, 220),\n      new ItemText('When a reverse tile is activated,', '55px Arial', 'rgb(2, 0, 139)', 10, 300),\n      new ItemText('rocks with the same, colour', '55px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText(\"break if they're altogether and\", '55px Arial', 'rgb(2, 0, 139)', 10, 450),\n      new ItemText(\"become altogether if they're apart.\", '55px Arial', 'rgb(2, 0, 139)', 10, 525)\n    ], LockedFeature.infoSwitch)\n\n    const teleporterSlide1 = new ItemSlide([\n      new ItemImage(false, images.TeleporterTomatoSprite_200x200, 625, 10),\n      ///\n      new ItemText('Teleporters', '120px Arial', 'purple', 10, 150),\n      new ItemText('When players go on teleporters', '55px Arial', 'rgb(2, 0, 139)', 10, 275),\n      new ItemText('they teleport to the matching', '55px Arial', 'rgb(2, 0, 139)', 10, 350),\n      new ItemText('teleporter.', '55px Arial', 'rgb(2, 0, 139)', 10, 425),\n      new ItemText('Only players can use teleporters.', '55px Arial', 'rgb(2, 0, 139)', 10, 525)\n    ], LockedFeature.infoTeleporter)\n\n    this.slides = [titleSlide, switchSlide1, switchSlide2, teleporterSlide1]\n  }\n};\n\nclass UnlockableInfo {\n  constructor () {\n    const titleSlide = new ItemSlide([\n      new ItemText('Unlockables', '150px Arial', 'purple', 10, 400)\n    ], 0)\n\n    const slide1 = new ItemSlide([\n      new ItemImage(false, images.UnlockRockBlue_200x200, 625, 10),\n      ///\n      new ItemText('Rocks', '200px Arial', 'purple', 10, 175),\n      new ItemText('Rocks act as barriers when altogether.', '49px Arial', 'rgb(2, 0, 139)', 10, 275),\n      new ItemText('When rocks are broken, anything can', '50px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText('go through them.', '50px Arial', 'rgb(2, 0, 139)', 10, 425),\n      new ItemText('Different rocks can have different', '50px Arial', 'rgb(2, 0, 139)', 10, 525),\n      new ItemText('colours.', '50px Arial', 'rgb(2, 0, 139)', 10, 575)\n\n    ], LockedFeature.infoRock)\n    this.slides = [titleSlide, slide1]\n  }\n};\n\nclass CollectableInfo {\n  constructor () {\n    const titleSlide = new ItemSlide([\n      new ItemText('Collectables', '150px Arial', 'purple', 10, 400)\n    ], 0)\n\n    const slide1 = new ItemSlide([\n      new ItemImage(false, images.LifeJacket_200x200, 625, 10),\n      //\n      new ItemText('Life Jackets', '115px Arial', 'purple', 10, 150),\n      new ItemText('When players pick up life jackets they', '50px Arial', 'rgb(2, 0, 139)', 10, 262.5),\n      new ItemText('can go in water.', '50px Arial', 'rgb(2, 0, 139)', 10, 337.5),\n      new ItemText('When cubers pick up life jackets', '50px Arial', 'rgb(2, 0, 139)', 10, 425),\n      new ItemText('they can move at nomral speed in', '50px Arial', 'rgb(2, 0, 139)', 10, 500),\n      new ItemText('water.', '50px Arial', 'rgb(2, 0, 139)', 10, 575)\n    ], LockedFeature.infoLifeJacket)\n    const slide2 = new ItemSlide([\n      new ItemImage(false, images.LifeJacket_200x200/* images.YellowKey_200x200 */, 625, 10),\n      //\n      new ItemText(' ', '120px Arial', 'purple', 10, 150)\n    ], LockedFeature.infoFinishItems)\n    const slide3 = new ItemSlide([\n      new ItemImage(false, images.LifeJacket_200x200/* images.FireShard_200x200 */, 625, 10),\n      //\n      new ItemText('', '120px Arial', 'purple', 10, 150)\n    ], LockedFeature.infoFireShard)\n    this.slides = [titleSlide, slide1, slide2, slide3]\n  }\n};\n\nclass TrapInfo {\n  constructor () {\n    const titleSlide = new ItemSlide([\n      new ItemText('Traps', '300px Arial', 'purple', 10, 400)\n    ], 0)\n\n    const slide1 = new ItemSlide([\n      new ItemImage(true, images.Hole_200x200, 550, 10, 200, 200, 0, 0, 200, 200),\n      ///\n      new ItemText('Holes', '200px Arial', 'purple', 10, 160),\n      new ItemText('When a player or enemy go over a hole,', '45px Arial', 'rgb(2, 0, 139)', 10, 275),\n      new ItemText('its cover starts to fall.', '45px Arial', 'rgb(2, 0, 139)', 10, 325),\n      new ItemText('Different holes have different amounts of', '45px Arial', 'rgb(2, 0, 139)', 10, 400),\n      new ItemText('times a player can go over it.', '45px Arial', 'rgb(2, 0, 139)', 10, 450),\n      new ItemText('When a player goes over a uncovered', '45px Arial', 'rgb(2, 0, 139)', 10, 525),\n      new ItemText('hole you lose.', '45px Arial', 'rgb(2, 0, 139)', 10, 575)\n    ], LockedFeature.infoHole)\n\n    const slide2 = new ItemSlide([\n      new ItemImage(true, images.Hole_200x200, 550, 10, 200, 200, 200, 0, 200, 200),\n      ///\n      new ItemText('Holes', '200px Arial', 'purple', 10, 160),\n      new ItemText('When a enemy goes over a', '60px Arial', 'rgb(2, 0, 139)', 10, 300),\n      new ItemText('uncovered hole they go the', '60px Arial', 'rgb(2, 0, 139)', 10, 375),\n      new ItemText('opposite way.', '60px Arial', 'rgb(2, 0, 139)', 10, 450)\n    ], LockedFeature.infoHole)\n    this.slides = [titleSlide, slide1, slide2]\n  }\n};\n\n\n//# sourceURL=webpack://cube-adventure/./files/menuModes/ItemInfo.js?");

/***/ }),

/***/ "./files/menuModes/Menu.js":
/*!*********************************!*\
  !*** ./files/menuModes/Menu.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MenuController\": () => (/* binding */ MenuController)\n/* harmony export */ });\n\nconst { gameMode, startingMenusStates, storyModeStates, ShopMode, gameStates, levelTools, settingStates } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nclass MenuItem {\n  constructor (title, valueX, valueY, color, action) {\n    this.title = title\n    this.valueX = valueX\n    this.valueY = valueY\n    this.color = color\n    this.action = action\n  }\n}\n\nclass Menu {\n  constructor (menuItems, width, height, offsetX, negativeOffsetX, offsetY, negativeOffsetY, textYOffset) {\n    this.menuItems = menuItems\n    this.selectedIndexX = 0\n    this.selectedIndexY = 0\n    this.width = width\n    this.height = height\n    this.offsetX = offsetX\n    this.negativeOffsetX = negativeOffsetX\n    this.offsetY = offsetY\n    this.negativeOffsetY = negativeOffsetY\n    this.textYOffset = textYOffset / 3\n    ///\n    this.menuItems.forEach(function (menuItem) {\n      menuItem.size = textYOffset + 'px Arial'\n    })\n  }\n\n  moveLeft () {\n    if (this.selectedIndexX !== 0) {\n      this.selectedIndexX = this.selectedIndexX - 1\n    }\n  }\n\n  moveRight () {\n    if (this.selectedIndexX !== this.width - 1) {\n      this.selectedIndexX = this.selectedIndexX + 1\n    }\n  }\n\n  moveUp () {\n    if (this.selectedIndexY !== 0) {\n      this.selectedIndexY = this.selectedIndexY - 1\n    }\n  }\n\n  moveDown () {\n    if (this.selectedIndexY !== this.height - 1) {\n      this.selectedIndexY = this.selectedIndexY + 1\n    }\n  }\n\n  selected () {\n    // Find the selected menuItem\n    const menuItem = this.menuItems[this.selectedIndexX * this.height + this.selectedIndexY]\n    menuItem.action()\n  }\n\n  Keydown (event, keybindArray, stopEvents) {\n    // Left \"Menus\"\n  if (keybindArray[0/* left */].keybindA === event.key || keybindArray[0/* left */].keybindB === event.key) { this.moveLeft() }\n\n  // Right \"Menus\"\n  if (keybindArray[1/* right */].keybindA === event.key || keybindArray[1/* right */].keybindB === event.key) { this.moveRight() }\n\n  // Down \"Menus\"\n  if (keybindArray[3/* down */].keybindA === event.key || keybindArray[3/* down */].keybindB === event.key) { this.moveDown() }\n\n  // Up \"Menus\"\n  if (keybindArray[2/* up */].keybindA === event.key || keybindArray[2/* up */].keybindB === event.key) { this.moveUp() }\n\n  // Selected \"Menus\"\n  if (keybindArray[4/* select */].keybindA === event.key || keybindArray[4/* select */].keybindB === event.key) {\n    this.selected()\n    if (gameStates.keybindController.seletingKeybind) { stopEvents.stopMouseUp = true }\n  }\n  }\n\n  Draw () {\n    const self = this\n    // Setting the width and height per menuItem\n    const heightPerItem = (this.negativeOffsetY - 5 - this.offsetY) / this.height\n    const widthPerItem = (this.negativeOffsetX - 5 - this.offsetX) / this.width\n    this.menuItems.forEach(function (menuItem) {\n      if ((menuItem.valueX - 1) === self.selectedIndexX && (menuItem.valueY - 1) === self.selectedIndexY) {\n        canvas.context.shadowColor = 'rgba(0, 0, 0, 0.8)'\n        canvas.context.shadowOffsetX = 5\n        canvas.context.shadowOffsetY = 5\n        canvas.context.fillStyle = 'rgba(128, 128, 128, 0.8)'\n        canvas.context.fillRect(self.offsetX + widthPerItem * (menuItem.valueX - 1), self.offsetY + heightPerItem * (menuItem.valueY - 1), widthPerItem, heightPerItem)\n        canvas.context.shadowOffsetX = 0\n        canvas.context.shadowOffsetY = 0\n        // Storing selector positions\n        gameStates.selectorX = widthPerItem * (menuItem.valueX - 1) + self.offsetX\n        gameStates.selectorXBottom = widthPerItem * menuItem.valueX + self.offsetX\n        gameStates.selectorY = heightPerItem * (menuItem.valueY - 1) + self.offsetY\n        gameStates.selectorYBottom = heightPerItem * menuItem.valueY + self.offsetY\n      }\n      // Drawing the MenuItem's text\n      canvas.context.font = menuItem.size\n      canvas.context.fillStyle = menuItem.color\n      const textX = widthPerItem * (menuItem.valueX - 1) + self.offsetX\n      const textY = heightPerItem * (menuItem.valueY - 1) + self.offsetY\n      canvas.context.textAlign = 'center'\n      canvas.context.fillText(menuItem.title, textX + widthPerItem / 2, textY + heightPerItem / 2 + self.textYOffset)\n      canvas.context.textAlign = 'left'\n    })\n  }\n}\n\nclass MenuController {\n  constructor () {\n    this.menus = []\n    this.menus.push(this.MainMenu = new Menu([\n      new MenuItem('Story Mode', 1, 1, 'rgb(0, 166, 255)', function () {\n        gameStates.currentStartingMenusState = startingMenusStates.Selected\n        gameStates.currentGameMode = gameMode.StoryMode\n      }),\n      new MenuItem('Customize', 1, 2, 'rgb(0, 132, 216)', function () {\n        gameStates.currentStartingMenusState = startingMenusStates.Selected\n        gameStates.currentGameMode = gameMode.Shop\n      }),\n      new MenuItem('Items Info', 1, 3, 'rgb(0, 67, 190)', function () {\n        gameStates.currentStartingMenusState = startingMenusStates.Selected\n        gameStates.currentGameMode = gameMode.ItemsInfo\n      }),\n      new MenuItem('Settings', 1, 4, 'rgb(0, 0, 139)', function () {\n        gameStates.currentStartingMenusState = startingMenusStates.Selected\n        gameStates.currentGameMode = gameMode.Settings\n      }),\n      new MenuItem('Comming Soon', 1, 5, 'rgb(55, 0, 110)', function () {\n\n      })\n    ], /* length */1, /* height */5, /* offsetX */0, /* negativeOffsetX */850, /* offsetY */0, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */90))\n\n    this.menus.push(this.ShopMenu = new Menu([\n      new MenuItem('Player', 1, 1, 'lightcoral', function () {\n        gameStates.currentShopMode = ShopMode.Player\n      }),\n      new MenuItem('Background', 1, 2, 'gold', function () {\n        gameStates.currentShopMode = ShopMode.Backround\n      })\n    ], /* length */1, /* height */2, /* offsetX */0, /* negativeOffsetX */850, /* offsetY */0, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */130))\n\n    this.menus.push(this.KeybindsSelector = new Menu([\n      new MenuItem('ArrowLeft', 1, 1, 'rgb(172, 0, 172)', function () { gameStates.keybindController.startRebind('A', 1, this) }),\n      new MenuItem('ArrowRight', 1, 2, 'rgb(183, 0, 158)', function () { gameStates.keybindController.startRebind('A', 2, this) }),\n      new MenuItem('ArrowUp', 1, 3, 'rgb(195, 0, 144)', function () { gameStates.keybindController.startRebind('A', 3, this) }),\n      new MenuItem('ArrowDown', 1, 4, 'rgb(207, 0, 130)', function () { gameStates.keybindController.startRebind('A', 4, this) }),\n      ///\n      new MenuItem('Space', 1, 5, 'rgb(219, 0, 116)', function () { gameStates.keybindController.startRebind('A', 5, this) }),\n      new MenuItem('Backspace', 1, 6, 'rgb(231, 0, 102)', function () { gameStates.keybindController.startRebind('A', 6, this) }),\n      new MenuItem('Shift', 1, 7, 'rgb(243, 0, 88)', function () { gameStates.keybindController.startRebind('A', 7, this) }),\n      new MenuItem('Column 1', 1, 8, 'rgb(255, 0, 75)', function () { gameStates.keybindController.resetKeybinds('A') }),\n      ///\n      ///\n      new MenuItem('a', 2, 1, 'rgb(172, 0, 172)', function () { gameStates.keybindController.startRebind('B', 1, this) }),\n      new MenuItem('d', 2, 2, 'rgb(183, 0, 158)', function () { gameStates.keybindController.startRebind('B', 2, this) }),\n      new MenuItem('w', 2, 3, 'rgb(195, 0, 144)', function () { gameStates.keybindController.startRebind('B', 3, this) }),\n      new MenuItem('s', 2, 4, 'rgb(207, 0, 130)', function () { gameStates.keybindController.startRebind('B', 4, this) }),\n      ///\n      new MenuItem('Enter', 2, 5, 'rgb(219, 0, 116)', function () { gameStates.keybindController.startRebind('B', 5, this) }),\n      new MenuItem('b', 2, 6, 'rgb(231, 0, 102)', function () { gameStates.keybindController.startRebind('B', 6, this) }),\n      new MenuItem('u', 2, 7, 'rgb(243, 0, 88)', function () { gameStates.keybindController.startRebind('B', 7, this) }),\n      new MenuItem('Column 2', 2, 8, 'rgb(255, 0, 75)', function () { gameStates.keybindController.resetKeybinds('B') })\n    ], /* length */2, /* height */8, /* offsetX */290, /* negativeOffsetX */850, /* offsetY */0, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */50))\n\n    this.menus.push(this.SettingsMenu = new Menu([\n      new MenuItem('Keybinds', 1, 1, 'rgb(230, 200, 0)', function () {\n        gameStates.SetGameState(settingStates.Keybinds, 'Settings')\n      }),\n      new MenuItem('Theme Colour', 1, 2, 'rgb(135, 200, 0)', function () {\n        gameStates.SetGameState(settingStates.ThemeColourSelection, 'Settings')\n      }),\n      new MenuItem('Comming Soon', 1, 3, 'rgb(0, 200, 0)', function () {\n        // gameStates.SetGameState(settingStates.Sound, \"Settings\")\n      })\n    ], /* length */1, /* height */3, /* offsetX */0, /* negativeOffsetX */850, /* offsetY */0, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */115))\n\n    this.menus.push(this.LoseMenu = new Menu([\n      new MenuItem('Retry', 1, 1, 'rgb(120, 0, 225)', function () {\n        levelTools.Restart()\n        gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n        levelTools.loseCounterStop = false\n      }),\n      new MenuItem('Selection Menu', 1, 2, 'rgb(90, 0, 225)', function () {\n        levelTools.Restart()\n        gameStates.SetGameState(storyModeStates.Selecting, 'StoryMode')\n        levelTools.loseCounterStop = false\n      }),\n      new MenuItem('Main Menu', 1, 3, 'rgb(60, 0, 225)', function () {\n        levelTools.Restart()\n        gameStates.SetGameState(storyModeStates.Selecting, 'StoryMode')\n        gameStates.currentStartingMenusState = startingMenusStates.Menu\n        levelTools.loseCounterStop = false\n      })\n    ], /* length */1, /* height */3, /* offsetX */0, /* negativeOffsetX */850, /* offsetY */175, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */115))\n\n    this.menus.push(this.WinMenu = new Menu([\n      new MenuItem('Continue', 1, 1, 'rgb(255, 0, 75)', function () {\n        if (gameStates.currentLevelIndex < gameStates.levelController.levels.length - 1) {\n          levelTools.NextLevel()\n          gameStates.currentLevelIndex++\n          gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n        }\n      }),\n      new MenuItem('Selection Menu', 1, 2, 'rgb(255, 5, 115)', function () {\n        levelTools.NextLevel()\n        gameStates.SetGameState(storyModeStates.Selecting, 'StoryMode')\n      }),\n      new MenuItem('Main Menu', 1, 3, 'rgb(255, 10, 150)', function () {\n        levelTools.NextLevel()\n        gameStates.SetGameState(storyModeStates.Selecting, 'StoryMode')\n        gameStates.currentStartingMenusState = startingMenusStates.Menu\n      })\n    ], /* length */1, /* height */3, /* offsetX */0, /* negativeOffsetX */850, /* offsetY */150, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */115))\n\n    this.menus.push(this.PauseMenu = new Menu([\n      new MenuItem('Resume', 1, 1, 'rgb(255, 0, 86)', function () {\n        gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n        gameStates.CurrentLevel().enemies.forEach(function (enemy) {\n          enemy.setTimer()\n        })\n      }),\n      new MenuItem('Retry', 1, 2, 'rgb(255, 85, 20)', function () {\n        levelTools.Restart()\n        gameStates.SetGameState(storyModeStates.Playing, 'StoryMode')\n      }),\n      new MenuItem('Selection Menu', 1, 3, 'rgb(255, 124, 0)', function () {\n        levelTools.Restart()\n        gameStates.SetGameState(storyModeStates.Selecting, 'StoryMode')\n      }),\n      new MenuItem('Main Menu', 1, 4, 'rgb(255, 170, 0)', function () {\n        levelTools.Restart()\n        gameStates.SetGameState(storyModeStates.Selecting, 'StoryMode')\n        gameStates.currentStartingMenusState = startingMenusStates.Menu\n      })\n    ], /* length */1, /* height */4, /* offsetX */0, /* negativeOffsetX */850, /* offsetY */0, /* negativeOffsetY */600, /* Used to find textOffsetY and fontSize */115))\n  }\n\n  CheckMenu () {\n    // Find the current menu\n    if (gameStates.currentStartingMenusState === startingMenusStates.Menu) { return 0 }\n    ///\n    if (gameStates.currentStartingMenusState === startingMenusStates.Selected) {\n      if (gameStates.currentShopMode === ShopMode.ShopMenu && gameStates.currentGameMode === gameMode.Shop) { return 1 }\n      ///\n      if (gameStates.currentGameMode === gameMode.Settings) {\n        if (gameStates.currentSettingState === settingStates.Keybinds && !gameStates.keybindController.seletingKeybind) { return 2 }\n        ///\n        if (gameStates.currentSettingState === settingStates.Selecting) { return 3 }\n      }\n      ///\n      if (gameStates.currentGameMode === gameMode.StoryMode) {\n        if (gameStates.currentStoryModeState === storyModeStates.Lost) { return 4 }\n        ///\n        if (gameStates.currentStoryModeState === storyModeStates.WonStage) { return 5 }\n        ///\n        if (gameStates.currentStoryModeState === storyModeStates.Paused) { return 6 }\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://cube-adventure/./files/menuModes/Menu.js?");

/***/ }),

/***/ "./files/startUp/cubeAdventure.js":
/*!****************************************!*\
  !*** ./files/startUp/cubeAdventure.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"game\": () => (/* binding */ game)\n/* harmony export */ });\n\nconst { KeybindController } = __webpack_require__(/*! ../events/Keybinds */ \"./files/events/Keybinds.js\")\nconst { ArrayChartController } = __webpack_require__(/*! ../menuModes/ArrayChart */ \"./files/menuModes/ArrayChart.js\")\nconst { MenuController } = __webpack_require__(/*! ../menuModes/Menu */ \"./files/menuModes/Menu.js\")\nconst { LevelController } = __webpack_require__(/*! ../levels/Levels */ \"./files/levels/Levels.js\")\nconst { Background } = __webpack_require__(/*! ../levels/Class */ \"./files/levels/Class.js\")\nconst { InfoController } = __webpack_require__(/*! ../menuModes/ItemInfo */ \"./files/menuModes/ItemInfo.js\")\nconst { images } = __webpack_require__(/*! ../drawing/Images */ \"./files/drawing/Images.js\")\nconst { draw } = __webpack_require__(/*! ../drawing/Draw */ \"./files/drawing/Draw.js\")\nconst { update } = __webpack_require__(/*! ../data/Update */ \"./files/data/Update.js\")\nconst { gameStates, dataManagement } = __webpack_require__(/*! ../data/GameData */ \"./files/data/GameData.js\")\nconst { canvas } = __webpack_require__(/*! ../drawing/Canvas */ \"./files/drawing/Canvas.js\")\nconst { Keydown, KeyUp } = __webpack_require__(/*! ../events/Keydown */ \"./files/events/Keydown.js\")\nconst { MouseDown } = __webpack_require__(/*! ../events/MouseDown */ \"./files/events/MouseDown.js\")\n/* const audio = {\n  MusicW1: new Audio(),\n  SetMusic: function () {\n    if (gameStates.currentStoryModeState === storyModeStates.Playing)\n            audio.MusicW1.play();\n        else\n            audio.MusicW1.pause();\n  }\n} */\n\nconst game = {\n  startTime: new Date(),\n  isRunning: true,\n  lastTime: new Date().getTime(),\n  ///\n  mainLoop: function () {\n    // const timePassed = new Date().getTime() - game.lastTime\n    game.lastTime = new Date().getTime()\n    /* if (!game.isRunning)\n            timePassed = 0\n        console.log('timePassed is: ', timePassed)\n        var delta = timePassed/20\n        console.log(delta)\n        if (delta > 1)\n        delta = 1 */\n    const delta = 1\n    dataManagement.Save(draw)\n    update.UpdateGame(delta)\n    draw.DrawGame()\n    window.setTimeout(game.mainLoop, 1000 / 120)\n    // window.requestAnimationFrame(game.mainLoop)\n  }\n}\n\nfunction handleVisibilityChange () {\n  if (document.visibilityState === 'hidden') {\n    console.log('it is hidden')\n    game.isRunning = false\n  } else {\n    console.log('it is showing')\n    game.lastTime = new Date().getTime()\n    game.isRunning = true\n  }\n}\n\nfunction ImageLoadingLoop () {\n  if (images.stillLoading > 0) {\n    window.setTimeout(ImageLoadingLoop, 1000 / 60)\n  } else {\n    StartGame()\n  }\n}\n\nfunction StartGame () {\n  canvas.createCanvasContext()\n  gameStates.loading = true\n  gameStates.levelController = new LevelController()\n  gameStates.background = new Background()\n  gameStates.infoController = new InfoController()\n  gameStates.menuController = new MenuController()\n  gameStates.arrayChartController = new ArrayChartController()\n  gameStates.keybindController = new KeybindController()\n  gameStates.levelController.createLevels()\n  dataManagement.Load(draw)\n  game.mainLoop()\n  gameStates.loading = false\n}\n\nfunction LoadGame () {\n  ///\n  if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i)) { gameStates.mobile = true } else { gameStates.mobile = false }\n  images.LoadImages()\n  // audio.MusicW1.src = \"musicName\";\n  ImageLoadingLoop()\n}\n\ndocument.addEventListener('visibilitychange', handleVisibilityChange, false)\ndocument.addEventListener('DOMContentLoaded', LoadGame)\ndocument.addEventListener('keydown', Keydown/* .bind(undefined, game) */)\ndocument.addEventListener('keyup', KeyUp/* .bind(undefined, game) */)\ndocument.addEventListener('mousedown', MouseDown/* .bind(undefined, game) */)\n\n\n//# sourceURL=webpack://cube-adventure/./files/startUp/cubeAdventure.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./files/startUp/cubeAdventure.js");
/******/ 	
/******/ })()
;